{
  "associatedLayout": "Exploration",
  "name": "Global EventsJS",
  "events": [
    {
      "colorB": 228,
      "colorG": 176,
      "colorR": 74,
      "creationTime": 0,
      "name": "Game Initialization",
      "source": "",
      "type": "BuiltinCommonInstructions::Group",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "BooleanVariable"
              },
              "parameters": [
                "DataInitialized",
                "False",
                ""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "colorB": 228,
              "colorG": 176,
              "colorR": 74,
              "creationTime": 0,
              "folded": true,
              "name": "Data Initialization and Object Groups",
              "source": "",
              "type": "BuiltinCommonInstructions::Group",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "gdjs.FDGameData = {}; // All persistent data is attached to gdjs so that it isn't reset on scene change",
                    "const FDSG = gdjs.FDGameData; // This way data can be accessed through a simpler variable name (FDSG = Frederick-Douglass Square Game)",
                    "",
                    "/// PUT ALL PERSISTENT DATA (FUNCTION DEFINITIONS AND VARIABLES AND STUFF) HERE! MAKE SURE TO PREFIX WITH 'FDSG.'!",
                    "",
                    "FDSG.GameVars = { // This holds variables that are important for tracking/managing the current game flags and variables",
                    "    runtimeScene: runtimeScene,",
                    "        // Used for accessing the current RuntimeScene object, since otherwise the definitions here will try and access the old object",
                    "}",
                    "const GameVars = FDSG.GameVars; // Simpler reference variable",
                    "const Game = GameVars.runtimeScene.getGame();",
                    "GameVars.DEBUG = GameVars.runtimeScene.getVariables().get(\"DEBUG\").getAsBoolean();",
                    "",
                    "GameVars.Constants = {} // Stores constant values to avoid magic numbers",
                    "",
                    "// OBJECT GROUPS ###################################################################################################################################",
                    "",
                    "// I find this to be an easier way to define object groups for use with this JavaScript-focused system",
                    "FDSG.ObjectGroups = {",
                    "    \"Collectibles\": [",
                    "        \"StatueCollectible\",",
                    "        \"ItemObject\" ",
                    "    ]",
                    "}"
                  ],
                  "parameterObjects": "",
                  "useStrict": true,
                  "eventsSheetExpanded": false
                }
              ],
              "parameters": []
            },
            {
              "colorB": 228,
              "colorG": 176,
              "colorR": 74,
              "creationTime": 0,
              "name": "Functions and Definitions",
              "source": "",
              "type": "BuiltinCommonInstructions::Group",
              "events": [
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "folded": true,
                  "name": "Class Definitions and Helper Functions",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::JsCode",
                      "inlineCode": [
                        "const FDSG = gdjs.FDGameData;",
                        "const GameVars = FDSG.GameVars;",
                        "",
                        "// CLASS DEFINITIONS ###############################################################################################################################",
                        "",
                        "FDSG.Classes = {};",
                        "",
                        "/**",
                        " * An object that organizes a group of object instances, tracking relative positions so that the whole group can be",
                        " * moved and scaled relative to each other. Useful if you have a collection of instances of different objects and",
                        " * want to move them all as one combined group",
                        " *      @property {RuntimeObject[]} instances Holds the actual RuntimeObjects in the InstanceGroup",
                        " *      @property {}",
                        " */",
                        "FDSG.Classes.InstanceGroup = class InstanceGroup {",
                        "    /**",
                        "     * @param {RuntimeObject[]} instances The object instances you want to group together, passed in an array",
                        "     */",
                        "    constructor(instances) {",
                        "        this._instanceData = []; // Holds an object for each instance in the group and its positional data",
                        "        this.x = null; // The x position of the InstanceGroup object",
                        "        this.y = null; // The y poition of the InstanceGroup object",
                        "        this.width = 0; // The overall width of the InstanceGroup object (the leftmost instance to the rightmost instance)",
                        "        this.height = 0; // The overall height of the InstanceGroup object (the topmost instance to the bottommost instance)",
                        "        this.scale = 1; // The scaling of the InstanceGroup",
                        "",
                        "        this._init(instances); // Scan instances to initialize necessary data",
                        "    }",
                        "",
                        "    /**",
                        "     * All object instances in this group",
                        "     *      @type {RuntimeObject[]}",
                        "     *      @readonly",
                        "     */",
                        "    get instances() {",
                        "        const instanceArray = [];",
                        "        for (const instanceData of this._instanceData) {",
                        "            instanceArray.push(instanceData.object);",
                        "        }",
                        "        return instanceArray;",
                        "    }",
                        "",
                        "    /**",
                        "     * Initializes important data by scanning instances",
                        "     *      @param {RuntimeObject[]} instances An array of object instances",
                        "     */",
                        "    _init(instances) {",
                        "        let minX = null; // Leftmost x position of instances",
                        "        let minY = null; // Topmost y position of instances",
                        "        let maxX = null; // Rightmost x position of instances, including instance width",
                        "        let maxY = null; // Bottommost y position of instances, including instance height",
                        "        for (const instance of instances) { // First we iterate through each instance to get general data for the InstanceGroup",
                        "            let x = instance.getX(), y = instance.getY(); // Instance position",
                        "            let width = instance.getWidth(), height = instance.getHeight(); // Instance dimensions",
                        "            if (minX == null || x < minX) { minX = x } // We want the leftmost x position so we can determine the relative positioning of all objects",
                        "            if (minY == null || y < minY) { minY = y } // We want the topmost y position so we can determine the relative positioning of all objects",
                        "            if (maxX == null || x + width > maxX) { maxX = x + width }",
                        "            if (maxY == null || y + height > maxY ) { maxY = y + height }",
                        "        }",
                        "        this.x = minX; // Set x to leftmost x position",
                        "        this.y = minY; // Set y to topmost y",
                        "        this.width = maxX - minX; // Calculate height of this object",
                        "        this.height = maxY - minY; // Calculate width of this object",
                        "        for (const instance of instances) { // Iterate a second time to set relative positions now that we know the size of the InstanceGroup",
                        "            const instanceData = {",
                        "                object: instance, // The RuntimeObject itself",
                        "                relX: instance.getX() - this.x, // The x position relative to the InstanceGroup",
                        "                relY: instance.getY() - this.y // The y position relative to the InstanceGroup",
                        "            }",
                        "            this._instanceData.push(instanceData);",
                        "        }",
                        "    }",
                        "",
                        "    /**",
                        "     * Moves all instances in the InstanceGroup to the desired position,",
                        "     * maintaining relative positioning across instances",
                        "     *      @param {number} x The X coordinate to move to",
                        "     *      @param {number} y The Y coordinate to move to",
                        "     */",
                        "    moveTo(x, y) {",
                        "        for (const instanceData of this._instanceData) { // Iterate through each instance of the group",
                        "            const instance = instanceData.object; // The actual RuntimeObject[]",
                        "            instance.setX(x + instanceData.relX); // Move the instance to given x coordinate, maintaining relative position in the group",
                        "            instance.setY(y + instanceData.relY); // Move the instance to given y coordinate, maintaining relative position in the group",
                        "        }",
                        "    }",
                        "",
                        "    /**",
                        "     * Scales the InstanceGroup, scaling and moving all object instances appropriately",
                        "     *      @param {number} newScale The new scale to resize to ",
                        "     */",
                        "    setScale(newScale) {",
                        "        if (newScale == 1) { return } // No point scaling by 1",
                        "        for (const instanceData of this._instanceData) {",
                        "            const instance = instanceData.object;",
                        "            instanceData.relX *= newScale;",
                        "            instanceData.relY *= newScale;",
                        "            instance.setX(x + instanceData.relX);",
                        "            instance.setY(y + instanceData.relY);",
                        "            instance.setWidth(instance.getWidth()*newScale);",
                        "            instance.setHeight(instance.getHeight()*newScale);",
                        "        }",
                        "        this.width *= newScale;",
                        "        this.height *= newScale;",
                        "        this.scale = newScale;",
                        "        if (newScale < 0) { // If the scale is negative, flip the object around the center rather than the origin",
                        "            this.x += this.width;",
                        "            this.y += this.height;",
                        "        }",
                        "    }",
                        "}",
                        "",
                        "",
                        "// HELPER FUNCTIONS ################################################################################################################################",
                        "",
                        "/**",
                        " * Returns all object names in the current game",
                        " *      @returns {string[]}",
                        "*/",
                        "FDSG.getAllObjects = function() {",
                        "    // Gets all object types in the game",
                        "    const objects = GameVars.runtimeScene._objects.items;",
                        "    const objectList = [];",
                        "    for (const object in objects) {",
                        "        objectList.push(object);",
                        "    }",
                        "    return objectList;",
                        "}",
                        "",
                        "FDSG.gdVartoJS = function(gdVar) {",
                        "    // Arrays",
                        "    if (gdVar.isArray()) {",
                        "        const arr = [];",
                        "        const children = gdVar.getAllChildren();",
                        "        for (const key in children) {",
                        "            const child = children[key];",
                        "            arr.push(gdVarToJS(child));",
                        "        }",
                        "        return arr;",
                        "    }",
                        "",
                        "    // Structures",
                        "    if (gdVar.isStructure()) {",
                        "        const obj = {};",
                        "        const children = gdVar.getAllChildren();",
                        "        for (const key in children) {",
                        "            obj[key] = gdVarToJS(children[key]);",
                        "        }",
                        "        return obj;",
                        "    }",
                        "",
                        "    // Primitives",
                        "    if (gdVar.isNumber()) return gdVar.getAsNumber();",
                        "    if (gdVar.isString()) return gdVar.getAsString();",
                        "    if (gdVar.isBoolean()) return gdVar.getAsBoolean();",
                        "",
                        "    return null;",
                        "}",
                        "",
                        "FDSG.jsToGDVar = function(jsValue, gdVar) {",
                        "    if (Array.isArray(jsValue)) {",
                        "        // Clear existing and rebuild as array",
                        "        gdVar.clearChildren();",
                        "        jsValue.forEach((v, i) => {",
                        "            const child = gdVar.getChild(i.toString());",
                        "            FDSG.jsToGDVar(v, child);",
                        "        });",
                        "        return;",
                        "    }",
                        "",
                        "    if (jsValue && typeof jsValue === \"object\") {",
                        "        // Structure: clear and rebuild",
                        "        gdVar.clearChildren();",
                        "        for (const key in jsValue) {",
                        "            const child = gdVar.getChild(key);",
                        "            FDSG.jsToGDVar(jsValue[key], child);",
                        "        }",
                        "        return;",
                        "    }",
                        "",
                        "    // Primitives",
                        "    if (typeof jsValue === \"number\") gdVar.setNumber(jsValue);",
                        "    else if (typeof jsValue === \"string\") gdVar.setString(jsValue);",
                        "    else if (typeof jsValue === \"boolean\") gdVar.setBoolean(jsValue);",
                        "    else gdVar.setString(\"\");",
                        "}",
                        "// FDSG.convertVariablesToJS = function(obj) {",
                        "//     const variables = obj.getVariables();",
                        "//     const allVars = variables.getAllChildren();",
                        "//     for (const variable in allVars) {",
                        "",
                        "//     }",
                        "",
                        "// }",
                        "",
                        "/**",
                        " * Prints a message to the console only if the DEBUG is set to true",
                        " *      @param {\"log\"|\"warn\"} type The type of log",
                        " *      @param {...any} arg The values to log ",
                        " */",
                        "FDSG.debugPrint = function(type, ...args) {",
                        "    if (GameVars.runtimeScene.getGame().getVariables().get(\"DEBUG\").getAsBoolean()) {",
                        "        if (type == \"warn\") {",
                        "            console.warn(...args);",
                        "        } else {",
                        "            console.log(...args);      ",
                        "        }",
                        "    }",
                        "}",
                        ""
                      ],
                      "parameterObjects": "",
                      "useStrict": true,
                      "eventsSheetExpanded": true
                    }
                  ],
                  "parameters": []
                },
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "folded": true,
                  "name": "Scenes and Layouts",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::JsCode",
                      "inlineCode": [
                        "const FDSG = gdjs.FDGameData;",
                        "const GameVars = FDSG.GameVars;",
                        "const Game = GameVars.runtimeScene.getGame();",
                        "",
                        "Object.assign(GameVars.Constants, {",
                        "    STARTING_LAYOUT: \"FDS North\", // First layout to load",
                        "    FIRST_TRANSITION_FADE_DURATION: 1000, // The duration of the fade from the Main Menu",
                        "    TRANSITION_FADE_DURATION: 150",
                        "});",
                        "",
                        "Object.assign(GameVars, {",
                        "    startLayout: GameVars.Constants.STARTING_LAYOUT, // The starting layout",
                        "    _currentLayout: GameVars.Constants.STARTING_LAYOUT, // This is used to load the corrent layout on transitions",
                        "    _isFading: false, // Used to halt input while fading in or out",
                        "    _currentLoadedMinigame: null // Used to track whether to check minigame flags on resuming this scene",
                        "});",
                        "",
                        "Object.defineProperty(GameVars, 'currentLayout', {",
                        "    get() { return this._currentLayout },",
                        "    set(newLayout) {",
                        "        FDSG.saveLayoutInstanceData();",
                        "        FDSG.initFade(GameVars.Constants.TRANSITION_FADE_DURATION, false);",
                        "        this._currentLayout = newLayout;",
                        "    }",
                        "});",
                        "",
                        "",
                        "FDSG._LayoutData = {}; // Used for tracking layout specific data",
                        "",
                        "FDSG._LayoutInspections = {}; // Used to hold all inspection data for the current layout",
                        "",
                        "FDSG.OnReturnFromMinigame = {}; // Used to hold functions that will run when returning from a minigame",
                        "",
                        "",
                        "/**",
                        " * Loads proper layouts for the scene and handles layout elements",
                        " */",
                        "FDSG.initScene = function() {",
                        "    // Loads proper layouts and initializes necessary values",
                        "    FDSG.debugPrint(\"log\",`initializing ${FDSG.GameVars.currentLayout}`);",
                        "    gdjs.evtTools.runtimeScene.createObjectsFromExternalLayout(GameVars.runtimeScene, \"UI\", 0, 0, false); // Load the UI",
                        "    gdjs.evtTools.runtimeScene.createObjectsFromExternalLayout(GameVars.runtimeScene, GameVars.currentLayout, 0, 0, false);",
                        "        // Load the layout for the current area",
                        "        ",
                        "    // Disable the darkening effects",
                        "    const backgroundLayer = GameVars.runtimeScene.getLayer(\"Background\");",
                        "    const objectsLayer = GameVars.runtimeScene.getLayer(\"SceneObjects\");",
                        "    const uiLayer = GameVars.runtimeScene.getLayer(\"UI\");",
                        "    const inspectionUILayer = GameVars.runtimeScene.getLayer(\"InspectionUI\");",
                        "    for (const layer of [backgroundLayer, objectsLayer, uiLayer]) {",
                        "        layer.enableEffect(\"Darken\", false);",
                        "    }",
                        "",
                        "    // Hide disabled layers",
                        "    for (const layer in FDSG.Input.ClickableLayers) {",
                        "        const runtimeLayer = GameVars.runtimeScene.getLayer(layer);",
                        "        runtimeLayer.show(FDSG.Input.ClickableLayers[layer]);",
                        "    }",
                        "",
                        "    // Run layout specific functions",
                        "    if (!(GameVars.currentLayout in FDSG._LayoutData)) {",
                        "        FDSG._LayoutData[GameVars.currentLayout] = {};",
                        "    }",
                        "    const layoutData = FDSG._LayoutData[GameVars.currentLayout];",
                        "    layoutData.hasBeenVisited = true; // Mark this layout as having been visited before. Used for Map teleportation",
                        "    if (\"onLayoutLoad\" in layoutData) { // Check if layout functions have been registered",
                        "        layoutData.onLayoutLoad(); // Run layout load function",
                        "    }",
                        "",
                        "    // COLLECTIBLES HANDLING",
                        "    FDSG.removeCollectedObjects(); // Removes any collected objects from the layout",
                        "",
                        "    FDSG.updateStatueCounter(); // Update the StatuesCollectedCounter to the proper value",
                        "",
                        "    // INSPECTIONS HANDLING",
                        "    FDSG._LayoutInspections = FDSG.getLayoutInspections(); // Registers all inspections and their objects for the current layout",
                        "    GameVars._loadedInspection = null; // No inspections are loaded on scene init",
                        "    GameVars._isInspecting = false; // Reset flag",
                        "",
                        "    // Set instance specific innerText on text objects",
                        "    // (this has to be done after InstanceGroups are created since changing text changes the size of text objects)",
                        "    for (const instance of FDSG.getAllSceneInstances()) { // Check for text objects and replace their text with the instance specific text",
                        "        if (instance.getVariables().has(\"innerText\")) {",
                        "            const iVars = instance.getVariables();",
                        "            let innerText = iVars.get(\"innerText\").getAsString();",
                        "            instance.setText(innerText); // Replace the text",
                        "            if (iVars.has(\"fontSize\")) { instance.setCharacterSize(iVars.get(\"fontSize\").getAsNumber()) }",
                        "            instance.setLineHeight(instance.getCharacterSize()*1.15);",
                        "                /* The default line height seems to be different across devices, so setting it manually",
                        "                like this seems to be the only way to keep it consistent*/ ",
                        "            if (iVars.has(\"outlineThickness\")) { instance.setOutlineThickness(iVars.get(\"outlineThickness\").getAsNumber()) }",
                        "            if (iVars.has(\"outlineColor\")) {instance.setOutlineColor(iVars.get(\"outlineColor\").getAsString()) }",
                        "        }",
                        "    }",
                        "",
                        "    // INVENTORY AND ITEM POPUPS",
                        "    if (FDSG.PlayerInventory._isInventoryShowing) {",
                        "        const inventoryUIBackground = GameVars.runtimeScene.getInstancesOf(\"InventoryUIBackground\")[0];",
                        "        const backpack = GameVars.runtimeScene.getInstancesOf(\"Backpack\")[0];",
                        "        let baseX = inventoryUIBackground.getX();",
                        "        let baseY = inventoryUIBackground.getY();",
                        "        let offsetX = GameVars.Constants.INVENTORY_OPEN_X_OFFSET;",
                        "        let offsetY = GameVars.Constants.INVENTORY_OPEN_Y_OFFSET;",
                        "        for (const instance of FDSG.getAllSceneInstances(\"InventoryUI\")) {",
                        "            instance.setX(instance.getX() - baseX + backpack.getX() + offsetX);",
                        "            instance.setY(instance.getY() - baseY + backpack.getY() + offsetY);",
                        "            if (instance.getName() != \"InspectInventoryItem\" && instance.getVariables().has(\"enabled\")) {",
                        "                instance.getVariables().get(\"enabled\").setBoolean(true);",
                        "            }",
                        "        }",
                        "    }",
                        "    FDSG.PlayerInventory._selectedItemName = null; // Remove stale references",
                        "    FDSG.PlayerInventory._selectedItemIndex = null;",
                        "    FDSG.PlayerInventory._itemObjects = [];",
                        "    FDSG.redrawInventory();",
                        "",
                        "    FDSG.loadLayoutInstanceData();",
                        "}",
                        "",
                        "/**",
                        " * Saves instance data to a JSON string and stores it",
                        " */",
                        "FDSG.saveLayoutInstanceData = function() {",
                        "    const layoutInstanceData = {};",
                        "    for (const instance of FDSG.getAllSceneInstances([\"SceneObjects\", \"InspectionObjects\"])) {",
                        "        if (instance.getVariables().has(\"instanceID\")) {",
                        "            const instanceID = instance.getVariables().get(\"instanceID\").getAsString();",
                        "            const instanceData = {};",
                        "            for (const variable in instance.getVariables()._variables.items) {",
                        "                instanceData[variable] = JSON.stringify(instance.getVariables().get(variable).toJSObject());",
                        "            }",
                        "            if (instance.getAnimationIndex != undefined) {",
                        "                instanceData.animation = instance.getAnimationIndex();",
                        "            }",
                        "            layoutInstanceData[instanceID] = instanceData;",
                        "        }",
                        "    }",
                        "    if (!(GameVars.currentLayout in FDSG._LayoutData)) {",
                        "        FDSG._LayoutData[GameVars.currentLayout] = {};",
                        "    }",
                        "    FDSG._LayoutData[GameVars.currentLayout].instanceData = layoutInstanceData;",
                        "}",
                        "",
                        "/**",
                        " * Loads all saved instanceData from JSON to the relevant scene instances",
                        " */",
                        "FDSG.loadLayoutInstanceData = function() {",
                        "    if (!(GameVars.currentLayout in FDSG._LayoutData)",
                        "    || (!(\"instanceData\" in FDSG._LayoutData[GameVars.currentLayout]))) {",
                        "        return;",
                        "    }",
                        "    const layoutInstanceData = FDSG._LayoutData[GameVars.currentLayout].instanceData;",
                        "    for (const instance of FDSG.getAllSceneInstances([\"SceneObjects\", \"InspectionObjects\"])) {",
                        "        if (instance.getVariables().has(\"instanceID\")) {",
                        "            const instanceID = instance.getVariables().get(\"instanceID\").getAsString();",
                        "            for (const variable in layoutInstanceData[instanceID]) {",
                        "                if (variable == \"animation\") {",
                        "                    instance.setAnimationIndex(layoutInstanceData[instanceID].animation);",
                        "                    continue;",
                        "                }",
                        "                const data = JSON.parse(layoutInstanceData[instanceID][variable]);",
                        "                FDSG.jsToGDVar(data, instance.getVariables().get(variable));",
                        "            }",
                        "        }",
                        "    }",
                        "}",
                        "",
                        "",
                        "/**",
                        " * Returns all instances of any object in the current scene",
                        " *      @param {string|string[]} layers? Only retrieve objects from these layers. Defaults to all layers",
                        " *      @param {gdjs.RuntimeScene?} runtimeScene the target runtimeScene. Defaults to current scene",
                        " *      @returns {gdjs.RuntimeObject[]} All instances in the current scene",
                        " */",
                        "FDSG.getAllSceneInstances = function(layers = \"all\", runtimeScene = null) {",
                        "    if (runtimeScene == null) {",
                        "        runtimeScene = GameVars.runtimeScene;",
                        "    }",
                        "    if (layers != \"all\" && !Array.isArray(layers)) {",
                        "        layers = [layers];",
                        "    }",
                        "    const instances = runtimeScene._instances.items;",
                        "    const layerInstances = [];",
                        "    for (const object in instances) {",
                        "        for (const instance of instances[object]) {",
                        "            if (layers.includes(instance.getLayer()) || layers == \"all\") {",
                        "                layerInstances.push(instance);",
                        "            }",
                        "        }",
                        "    }",
                        "    return layerInstances.slice();",
                        "}",
                        "",
                        "/**",
                        " * Returns an Object with all objects and their instances on the given scene",
                        " *      @param {string|string[]} layers? Only retrieve objects from these layer. Defaults to all layers",
                        " *      @returns {Object} All objects in the given scene and their instances",
                        " */",
                        "FDSG.getAllSceneObjects = function(layers = \"all\", runtimeScene = null) {",
                        "    if (runtimeScene == null) {",
                        "        runtimeScene = GameVars.runtimeScene;",
                        "    }",
                        "    if (layers != \"all\" && !Array.isArray(layers)) {",
                        "        layers = [layers];",
                        "    }",
                        "    const sceneObjects = {};",
                        "    const sceneInstances = FDSG.getAllSceneInstances(layers);",
                        "    for (const instance of sceneInstances) {",
                        "        if (!(instance.name in sceneObjects)) {",
                        "            sceneObjects[instance.name] = [];",
                        "        }",
                        "        sceneObjects[instance.name].push(instance);",
                        "    }",
                        "    return sceneObjects;",
                        "}",
                        "",
                        "/**",
                        " * Returns the object instance with the given ID",
                        " *      @param {string} id The instanceID to look for",
                        " */",
                        "FDSG.getInstanceFromID = function(id) {",
                        "    const instances = FDSG.getAllSceneInstances();",
                        "    for (const instance of instances) {",
                        "        if (!instance.getVariables().has(\"instanceID\")) {",
                        "            continue;",
                        "        }",
                        "        if (instance.getVariables().get(\"instanceID\").getAsString() == id) {",
                        "            return instance;",
                        "        }",
                        "    }",
                        "}",
                        "",
                        "/**",
                        " * Starts the fadeIn/fadeOut effect",
                        " *      @param {number} duration How long the effect should take to finish",
                        " *      @param {boolean} fadeIn fadeIn Set as true to fade in, false to fade out",
                        " */",
                        "FDSG.initFade = function(duration, fadeIn) {",
                        "    const cameraWidth = gdjs.evtTools.camera.getCameraWidth(GameVars.runtimeScene, \"\", 0); ",
                        "    const cameraHeight = gdjs.evtTools.camera.getCameraHeight(GameVars.runtimeScene, \"\", 0);",
                        "    const fadeScreen = GameVars.runtimeScene.createObject(\"FadeScreen\");",
                        "    fadeScreen.setLayer(\"SceneObjects\");",
                        "    fadeScreen.setZOrder(99);",
                        "    fadeScreen.setWidth(cameraWidth); // Make the fadeScreen cover the screen",
                        "    fadeScreen.setHeight(cameraHeight);",
                        "    if (fadeIn) {",
                        "        fadeScreen.getVariables().get(\"Opacity\").setNumber(1);",
                        "        fadeScreen.getVariables().get(\"FadeDuration\").setNumber(duration);",
                        "    } else {",
                        "        fadeScreen.getVariables().get(\"Opacity\").setNumber(0);",
                        "        fadeScreen.getVariables().get(\"FadeDuration\").setNumber(-duration);",
                        "    }",
                        "    GameVars._isFading = true;",
                        "}",
                        "",
                        "/**",
                        " * Registers a function to run when the given layout is loaded. Useful for scripted events",
                        " *      @param {string} layoutName The name of the layout",
                        " *      @param {() => {}} onLayoutLoadFunction The function to run when the layout is loaded",
                        " */",
                        "FDSG.registerOnLayoutLoadFunction = function(layoutName, onLayoutLoadFunction) {",
                        "    if (!(layoutName in FDSG._LayoutData)) {",
                        "        FDSG._LayoutData[layoutName] = {};",
                        "    }",
                        "    FDSG._LayoutData[layoutName].onLayoutLoad = onLayoutLoadFunction;",
                        "",
                        "}",
                        "",
                        "/**",
                        " * Loads a minigame scene, setting the proper flags to check onReturnFromMinigame functions when we return",
                        " *      @param {string} minigameName The name of the minigame. Case sensitive!",
                        " */",
                        "FDSG.loadMinigame = function(minigameName) {",
                        "    FDSG.debugPrint(\"log\",`Loading minigame ${minigameName}`);",
                        "    GameVars._currentLoadedMinigame = minigameName;",
                        "    FDSG.initFade(GameVars.Constants.FIRST_TRANSITION_FADE_DURATION/2, true); /* Set so the game will fade back in on return */",
                        "    gdjs.evtTools.runtimeScene.pushScene(GameVars.runtimeScene, minigameName);",
                        "}",
                        "",
                        "",
                        "/**",
                        " * Register a function to run when returning from the given minigame",
                        " *      @param {string} minigameName The name of the minigame",
                        " *      @param {() => {}} returnFunction",
                        " */",
                        "FDSG.registerOnReturnFromMinigame = function(minigameName, returnFunction) {",
                        "    FDSG.OnReturnFromMinigame[minigameName] = returnFunction;",
                        "}",
                        "",
                        ""
                      ],
                      "parameterObjects": "",
                      "useStrict": true,
                      "eventsSheetExpanded": true
                    }
                  ],
                  "parameters": []
                },
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "folded": true,
                  "name": "Player Input",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::JsCode",
                      "inlineCode": [
                        "const FDSG = gdjs.FDGameData;",
                        "const GameVars = FDSG.GameVars;",
                        "",
                        "GameVars.runtimeScene.getGame().getInputManager().touchSimulateMouse(false); // Disable the touch inputs from simulating mouse clicks",
                        "",
                        "FDSG.Input = { // Stores objects and variables for handling player input",
                        "    _currentHoveredInstance: null, // The instance that is currently selected by mouse or touch",
                        "    _lastObjectPressed: null, /* This stores the last object that was clicked. We use this to ensure that in order to click an object,",
                        "                                the mouse has to be hovering over it before any input, so as to avoid dragging clicks or",
                        "                                in the case of a UI element appearing underneath the cursor while clicking */",
                        "    _deviceSupportsTouch: ('ontouchstart' in window || navigator.maxTouchPoints > 0), // If the device supports touchscreen",
                        "    _lastTouchX: null,",
                        "    _lastTouchY: null,",
                        "    _currentInputMethod: \"Mouse\", // This is for knowing whether or not we're using the touchscreen",
                        "}",
                        "",
                        "FDSG.Input.ClickableObjects = {}; // Stores registered actions to run when objects are clicked",
                        "",
                        "FDSG.Input.ClickableLayers = { // Similar but for disabling layers instead of individual objects",
                        "    \"SceneObjects\": true,",
                        "    \"UI\": true,",
                        "    \"InspectionObjects\": false,",
                        "    \"InspectionUI\": false,",
                        "    \"InventoryUI\": true,",
                        "    \"ItemPopup\": false,",
                        "    \"MapPopup\": false,",
                        "}",
                        "",
                        "FDSG.Input.KeyPressFunctions = {}; // Stores keyboard inputs and their registered functions",
                        "",
                        "FDSG.Input.HoverTooltips = {}; // Stores text that displays when the mouse is hovering over an object",
                        "",
                        "GameVars.Constants.SHOW_MOUSE_COORDS = true;",
                        "",
                        "",
                        "const input = GameVars.runtimeScene.getGame().getInputManager();",
                        "",
                        "",
                        "/**",
                        " * Registers a function to run when an object is clicked or tapped.",
                        " *      @param {Object} clickConfig The object that holds the listed parameters",
                        " *      @param {string|string[]} clickConfig.object The object type or array of object types to register",
                        " *      @param {\"pressed\"|\"released\"} clickConfig.duration Whether to trigger while clicking or just release",
                        " *      @param {(obj: gdjs.RuntimeObject) => void} clickConfig.clickFunction The function that runs when clicked",
                        " *      // OPTIONAL",
                        " *      @param {string} clickConfig.cursor? Optional cursor to show on hover. Defaults to pointer",
                        " *      @param {(obj: gdjs.RuntimeObject) => void} hoverFunction Optional function to run when hovering over object",
                        " *      @param {effectData} clickConfig.hoverEffect? Optional effect to play on highlight.",
                        " *      @param {string} clickConfig.hoverTooltip? Optional text to display when hovering over object",
                        " *              ",
                        " */",
                        "FDSG.registerClickableObject = function(clickConfig) {",
                        "    let objects = clickConfig.object;",
                        "    // let clickButtons = clickConfig.button; // We're only using left clicks to keep touchscreen support",
                        "    let clickDuration = clickConfig.duration;",
                        "    let cursor = (typeof clickConfig.cursor === 'undefined') ? \"pointer\" : clickConfig.cursor; // Cursor defaults to \"pointer\"",
                        "    let hoverFunction = (typeof clickConfig.hoverFunction === 'undefined') ? null : clickConfig.hoverFunction;",
                        "    let hoverEffect = (typeof clickConfig.hoverEffect === 'undefined') ? null : clickConfig.hoverEffect;",
                        "    let hoverTooltip = (typeof clickConfig.hoverTooltip === 'undefined') ? null : clickConfig.hoverTooltip;",
                        "    /* We put the following parameters in arrays if they're not already.",
                        "        This is probably overkill since it's unlikely more than one object will be tied to a function, but this only runs once at startup",
                        "        so it's not gonna affect performance or anything */",
                        "    if (!Array.isArray(objects)) {",
                        "        objects = [clickConfig.object];",
                        "    }",
                        "    for (const object of objects) {",
                        "        if (!(object in FDSG.Input.ClickableObjects)) {",
                        "            FDSG.Input.ClickableObjects[object] = { // Register the object as clickable and store the necessary properties",
                        "                clickFunctions: {}, // Stores functions that run when left clicked or tapped",
                        "                hoverFunctions: [], // Stores functions that run when hovering over object",
                        "                cursor: cursor, // What the cursor should turn into when hovering over",
                        "                enabled: true // Useful for disabling interactivity on this object",
                        "            }",
                        "        }",
                        "        let clickObject = FDSG.Input.ClickableObjects[object]; // Easier reference variable",
                        "        // Clickfunction",
                        "        if (!(clickDuration in clickObject.clickFunctions)) { // Register the duration",
                        "            clickObject.clickFunctions[clickDuration] = {};",
                        "        }",
                        "        clickObject.clickFunctions[clickDuration] = clickConfig.clickFunction; // Assign the clickFunction",
                        "        // Hoverfunction",
                        "        if (hoverFunction != null) {",
                        "             clickObject.hoverFunctions.push(hoverFunction); // Add the function to the array",
                        "        }",
                        "        // HoverEffect",
                        "        if (hoverEffect != null) { // We just use a simple function to add hoverEffects",
                        "            clickObject.hoverFunctions.push((obj) => {",
                        "                hoverEffect.name = \"hoverEffect\";",
                        "                obj.addEffect(hoverEffect);",
                        "            });",
                        "        }",
                        "        // HoverTooltip",
                        "        if (hoverTooltip != null) {",
                        "            FDSG.Input.HoverTooltips[object] = hoverTooltip;",
                        "        }",
                        "    }",
                        "}",
                        "",
                        "/**",
                        " * Registers a key to a given function",
                        " *      @param {Object} keyConfig The object that holds the listed parameters",
                        " *      @param {string|string[]} keyConfig.keys The key that triggers the function",
                        " *      @param {\"pressed\"|\"justPressed\"|\"released\"} keyConfig.duration Whether to trigger on press, pressed this frame, or just release",
                        " *      @param {() => void} keyConfig.keyPressFunction The function that runs when clicked",
                        " */",
                        "FDSG.registerKeyPressFunction = function(keyConfig) {",
                        "    let keys = keyConfig.key; // Which key or keys to press",
                        "    if (!Array.isArray(keys)) {",
                        "        keys = [keys];",
                        "    }",
                        "    for (const key of keys) {",
                        "        if (!(key in FDSG.Input.KeyPressFunctions)) {",
                        "            FDSG.Input.KeyPressFunctions[key] = {",
                        "                keyPressFunctions: {},",
                        "                enabled: true",
                        "            }",
                        "        }",
                        "        FDSG.Input.KeyPressFunctions[key].keyPressFunctions[keyConfig.duration] = keyConfig.keyPressFunction; // Assign the function",
                        "    }",
                        "}",
                        "",
                        "",
                        "/**",
                        " * Checks player input and runs the appropriate functions",
                        " */",
                        "FDSG.handlePlayerInput = function() {",
                        "    // CLICKABLE OBJECTS AND MOUSE INPUT",
                        "    const input = GameVars.runtimeScene.getGame().getInputManager(); // gdjs Input manager",
                        "    let highestZOrder = -99; // If multiple items are in the same place, we only worry about the one on top",
                        "    let cursor = \"default\"; // Default cursor type",
                        "    let enableClickFunctions = true; // Whether to allow clickFunctions to run",
                        "    let hoveredInstance = null; // Which instance is currently being hovered over",
                        "    let selectedItemIndex = FDSG.PlayerInventory.selectedItemIndex; // The currently selected inventory item",
                        "",
                        "    let touchIDs = input.getAllTouchIdentifiers(); // Currently active touchscreen inputs",
                        "    let touchJustStartedIDs = input.getStartedTouchIdentifiers(); // Touchscreen inputs that began this frame",
                        "    let isTouchActive = false;",
                        "",
                        "    let isPressed = gdjs.evtTools.input.isMouseButtonPressed(GameVars.runtimeScene, \"Left\"); // If a touch or click is active this frame",
                        "    let isReleased = gdjs.evtTools.input.isMouseButtonReleased(GameVars.runtimeScene, \"Left\"); // If a touch or click was released this frame",
                        "    let touchJustStarted = false; // If the touch just began this frame",
                        "",
                        "    // Determine input method and status",
                        "    /* !!IMPORTANT!! GDEVELOP TREATS MOUSE CLICKS AS TOUCH INPUTS, BUT THEY WILL ALWAYS HAVE THE ID OF 1!",
                        "        ACTUAL TOUCHSCREEN INPUTS WILL ALWAYS HAVE AN ID > 1!! */",
                        "    if (touchIDs.includes(2)) { // Gets the status of the touchscreen to determine input.",
                        "        if (FDSG.Input._currentInputMethod != \"Touch\") {",
                        "            FDSG.debugPrint(\"log\",\"Changing input method to Touch\");",
                        "            FDSG.Input._currentInputMethod = \"Touch\";",
                        "        }",
                        "        isTouchActive = true; // Whether the touchscreen is currently being used",
                        "        if (input.hasTouchEnded(2)) {",
                        "            isReleased = true;",
                        "        } else {",
                        "            isPressed = true;",
                        "            FDSG.Input._lastTouchX = input.getTouchX(2);",
                        "            FDSG.Input._lastTouchY = input.getTouchY(2);",
                        "        } if (touchJustStartedIDs.includes(2)) {",
                        "            touchJustStarted = true;",
                        "        }",
                        "    } else { // No touch input",
                        "        FDSG.Input._lastTouchX = null;",
                        "        FDSG.Input._lastTouchY = null;",
                        "        if (gdjs.evtTools.input.isMouseButtonPressed(GameVars.runtimeScene, \"Left\")",
                        "        || gdjs.evtTools.input.isMouseButtonReleased(GameVars.runtimeScene, \"Left\")) {",
                        "            if (FDSG.Input._currentInputMethod != \"Mouse\") {",
                        "                FDSG.debugPrint(\"log\",\"Changing input method to Mouse\");",
                        "                FDSG.Input._currentInputMethod = \"Mouse\";",
                        "            }",
                        "            ",
                        "        }",
                        "    }",
                        "    // Determine currently hovered object",
                        "    if (!GameVars._isFading) { // Don't allow inputs during transition fade",
                        "        for (const object in FDSG.Input.ClickableObjects) { // Check each object to determine which object the mouse is hovering over (if any)",
                        "            const clickObject = FDSG.Input.ClickableObjects[object]; // Simpler reference variable",
                        "            const instances = GameVars.runtimeScene.getInstancesOf(object);",
                        "            for (const instance of instances) { // Check each instance of the object",
                        "                instance.removeEffect(\"hoverEffect\");",
                        "                if (!clickObject.enabled) { continue } // Check if the object is disabled",
                        "                if (instance.getVariables().has(\"enabled\") && !instance.getVariables().get(\"enabled\").getAsBoolean()) { continue }",
                        "                    // Skip if instance is disabled",
                        "                if (selectedItemIndex != null",
                        "                && instance.getName() != \"InspectInventoryItem\"",
                        "                && (!instance.getVariables().has(\"targetInteraction\")",
                        "                    || !instance.getVariables().get(\"canUseItems\").getAsBoolean())) { continue }",
                        "                    // We only want to check clicks on interaction objects as long as an item is selected",
                        "                let instanceLayer = instance.getLayer();",
                        "                if (!FDSG.Input.ClickableLayers[instanceLayer]) { continue } // Skip instances on disabled layers",
                        "                if (isTouchActive) { // If Touchscreen is being used",
                        "                    var touchX = input.getTouchX(2);",
                        "                    var touchY = input.getTouchY(2);",
                        "                } else {",
                        "                    var touchX = null; // Tracks the currently touched screen position",
                        "                    var touchY = null;",
                        "                }",
                        "                let lastTouchX = FDSG.Input._lastTouchX;",
                        "                let lastTouchY = FDSG.Input._lastTouchY;",
                        "                if ((FDSG.Input._currentInputMethod == \"Mouse\" && instance.cursorOnObject())",
                        "                || (touchX != null && instance.isCollidingWithPoint(touchX, touchY))",
                        "                || (touchX == null && instance.isCollidingWithPoint(lastTouchX, lastTouchY))) {",
                        "                    // Check if the cursor is on the object and if its layer is not disabled",
                        "                    let zOrder = instance.getZOrder(); // This determines which objects are shown in front of/behind other objects",
                        "                    if (zOrder > highestZOrder) { // Only set cursor for the object with the highest Z order",
                        "                        cursor = clickObject.cursor;",
                        "                        hoveredInstance = instance;",
                        "                    }",
                        "                }",
                        "            }",
                        "        }",
                        "    }",
                        "    ",
                        "    // This is all so that you don't accidentally release on an object you didn't click",
                        "    if ((!isPressed && !isReleased) || (touchJustStarted)) {",
                        "        FDSG.Input._lastObjectPressed = hoveredInstance;",
                        "    } else if (isPressed && hoveredInstance != FDSG.Input._lastObjectPressed) {",
                        "        enableClickFunctions = false;",
                        "        FDSG.Input._lastObjectPressed = null;",
                        "    } else if (isReleased && hoveredInstance != FDSG.Input._lastObjectPressed) {",
                        "        enableClickFunctions = false;",
                        "        FDSG.Input._lastObjectPressed = null;",
                        "    }",
                        "",
                        "    GameVars.runtimeScene.getGame().getRenderer().getCanvas().style.cursor = cursor; // Change the cursor",
                        "",
                        "    // InventoryItem Cursor handling",
                        "    const canTouch = FDSG.Input._deviceSupportsTouch; // Used to check for touchscreen compatibility",
                        "    if (selectedItemIndex != null && !canTouch ) {",
                        "            // Only run if the current device does not have a touchscreen to avoid bugs",
                        "        var itemCursor = FDSG.getAllSceneInstances(\"MouseCursor\");",
                        "        if (itemCursor.length > 0) {",
                        "            var itemCursor = itemCursor[0];",
                        "            //if (FDSG.Input._currentInputMethod == \"Mouse\") {",
                        "            let xOffset = GameVars.Constants.ITEM_CURSOR_X_OFFSET;",
                        "            let yOffset = GameVars.Constants.ITEM_CURSOR_Y_OFFSET;",
                        "            itemCursor.setX(gdjs.evtTools.input.getCursorX(GameVars.runtimeScene) + xOffset); // Make the itemCursor follow the mouse;",
                        "            itemCursor.setY(gdjs.evtTools.input.getCursorY(GameVars.runtimeScene) + yOffset); // Make the itemCursor follow the mouse;",
                        "        }",
                        "    }",
                        "",
                        "    // Manage HoverTooltips",
                        "    FDSG.handleHoverTooltip(hoveredInstance);",
                        "",
                        "    // CLICK & HOVER FUNCTIONS",
                        "    if (hoveredInstance != null) {",
                        "        FDSG.Input._currentHoveredInstance = hoveredInstance;",
                        "        const instanceVars = hoveredInstance.getVariables();",
                        "",
                        "        // HOVER FUNCTIONS",
                        "        for (const func of FDSG.Input.ClickableObjects[hoveredInstance.getName()].hoverFunctions) {",
                        "            func(hoveredInstance);",
                        "        }",
                        "",
                        "        // CLICK FUNCTIONS",
                        "        if (enableClickFunctions) {",
                        "            const clickObject = FDSG.Input.ClickableObjects[hoveredInstance.getName()]; // Simpler reference variable",
                        "            if (FDSG.PlayerInventory.selectedItem == null",
                        "            || hoveredInstance.getName() == \"InspectInventoryItem\"",
                        "            || (hoveredInstance.getVariables().has(\"targetInteraction\"))",
                        "                && hoveredInstance.getVariables().get(\"canUseItems\").getAsBoolean()) {",
                        "                // We only check interaction objects that accept items while an item is selected",
                        "                for (const clickDuration in clickObject.clickFunctions) {",
                        "                    if ((clickDuration == \"pressed\" && isPressed) || (clickDuration == \"released\" && isReleased)) {",
                        "                        if (hoveredInstance.getName() != \"InteractionObject\"",
                        "                        && hoveredInstance.getName() != \"InteractionButton\"",
                        "                        && hoveredInstance.getVariables().has(\"targetInteraction\")) {",
                        "                            // Run interactions tied to the object. We skip interaction objects to avoid running them twice",
                        "                            const interactionData = FDSG.Interactions[hoveredInstance.getVariables().get(\"targetInteraction\").getAsString()];",
                        "                            interactionData.interactionFunction(hoveredInstance);",
                        "                            if (!interactionData.runUsual) {",
                        "                                continue;",
                        "                            } ",
                        "                        }",
                        "                        FDSG.debugPrint(\"log\", `running clickfunction for: ${hoveredInstance.getName()}`)",
                        "                        clickObject.clickFunctions[clickDuration](hoveredInstance); // Run the function",
                        "                    }",
                        "                }",
                        "            }",
                        "        }",
                        "    } else if (isReleased && FDSG.PlayerInventory.selectedItem != null) {",
                        "        FDSG.PlayerInventory.selectedItem = null; // Clear selected item on click",
                        "    }",
                        "",
                        "    // if (GameVars.DEBUG && GameVars.Constants.SHOW_MOUSE_COORDS) {",
                        "    //     const debugCursorText = GameVars.runtimeScene.getInstancesOf(\"DebugText\")[0];",
                        "    //     const cursorX = gdjs.evtTools.input.getCursorX(GameVars.runtimeScene);",
                        "    //     const cursorY = gdjs.evtTools.input.getCursorY(GameVars.runtimeScene);",
                        "    //     debugCursorText.setText(`${cursorX}, ${cursorY}`);",
                        "    //     debugCursorText.setX(cursorX);",
                        "    //     debugCursorText.setY(cursorY);",
                        "    // }",
                        "    // KEYBOARD INPUT",
                        "    for (const key in FDSG.Input.KeyPressFunctions) {",
                        "        const keyData = FDSG.Input.KeyPressFunctions[key];",
                        "        if (keyData.enabled) {",
                        "            //let keyCode = gdjs.evtTools.input.keysNameToCode[key];",
                        "            let keyPressed = gdjs.evtTools.input.isKeyPressed(GameVars.runtimeScene, key);",
                        "            let keyJustPressed = gdjs.evtTools.input.wasKeyJustPressed(GameVars.runtimeScene, key);",
                        "            let keyReleased = gdjs.evtTools.input.wasKeyReleased(GameVars.runtimeScene, key);",
                        "            for (const duration in keyData.keyPressFunctions) {",
                        "                if ((duration == \"pressed\" && keyPressed)",
                        "                || (duration == \"justPressed\" && keyJustPressed)",
                        "                || (duration == \"released\" && keyReleased)) {",
                        "                    keyData.keyPressFunctions[duration](); // Run the function",
                        "                }",
                        "            }",
                        "        }",
                        "    }",
                        "}",
                        "",
                        "",
                        "/**",
                        " * Enables/Disables the clickFunctions of a given object. Useful for pausing functionality under specific circumstances",
                        " *      @param {string} object The type of object",
                        " *      @param {boolean} enable Set to true to enable the object, set to false to disable the object",
                        " */",
                        "FDSG.enableObjectClick = function(object, enable) {",
                        "    if (!(object in FDSG.Input.ClickableObjects)) {",
                        "        FDSG.debugPrint(\"log\",`Warning: ${object} not registered as clickable!`);",
                        "        return",
                        "    }",
                        "    FDSG.Input.ClickableObjects[object].enabled = enable;",
                        "}",
                        "",
                        "",
                        "/**",
                        " * Enables/Disables the clickFunctions of all objects on a given layer. Useful for pausing functionality under specific circumstances",
                        " *      @param {string|string[]} layers The target layer or layers",
                        " *      @param {boolean} enable Set to true to enable the layer, set to false to disable the layer",
                        " */",
                        "FDSG.enableLayerClick = function(layers, enable) {",
                        "    if (!Array.isArray(layers)) {",
                        "        layers = [layers];",
                        "    }",
                        "    for (const layer of layers) {",
                        "        if (!(layer in FDSG.Input.ClickableLayers)) {",
                        "            FDSG.debugPrint(\"log\",`Warning: ${layer} not registered as clickable!`);",
                        "            return",
                        "        }",
                        "        FDSG.Input.ClickableLayers[layer] = enable;",
                        "    }",
                        "}",
                        "",
                        "/**",
                        " * Enable or Disable a keyPressFunction",
                        " *      @param {string|string[]} keys The key or array of keys to enable/disable",
                        " *      @param {boolean} enable Set to true to enable function, false to disable",
                        " */",
                        "FDSG.enableKey = function(key, enable) {",
                        "    if (!Array.isArray(keys)) {",
                        "        key = [keys];",
                        "    }",
                        "    for (const key of keys) {",
                        "        FDSG.Input.KeyPressFunctions[key].enabled = enable;",
                        "    }",
                        "}",
                        "",
                        "/**",
                        " * Handles the creation and display of \"HoverTooltips\" when hovering over an instance",
                        " *      @param {gdjs.RuntimeObject} hoveredInstance The object instance currently being hovered",
                        " */",
                        "FDSG.handleHoverTooltip = function(hoveredInstance) {",
                        "    // Clear existing hoverTooltips",
                        "    const linksManager = gdjs.LinksManager.getManager(GameVars.runtimeScene);",
                        "    for (const hoverTooltip of GameVars.runtimeScene.getInstancesOf(\"HoverTooltip\")) {",
                        "        const linkedObjects = linksManager.getObjectsLinkedWith(hoverTooltip);",
                        "        if (!linkedObjects.length > 0 || !linkedObjects.includes(hoveredInstance)) {",
                        "            hoverTooltip.deleteFromScene(); // Delete all hoverTooltips not tied to the hoveredInstance",
                        "        }",
                        "    }",
                        "",
                        "    if (hoveredInstance != null) {",
                        "        const instanceVars = hoveredInstance.getVariables();",
                        "        var hoverTooltip = null; // Text to display when hovering over object",
                        "        const linkedTooltip = linksManager.getObjectsLinkedWithAndNamed(hoveredInstance, \"HoverTooltip\");",
                        "        if (linkedTooltip.length > 0) {",
                        "            hoverTooltip = null; // Don't bother doing anything if the tooltip already exists",
                        "        } else if (instanceVars.has(\"hoverTooltip\")) { // If the instance or object has been given hoverTooltip",
                        "            var hoverTooltipData = instanceVars.get(\"hoverTooltip\");",
                        "            var text = hoverTooltipData.getChild(\"text\").getAsString();",
                        "            var bold = hoverTooltipData.getChild(\"bold\").getAsBoolean();",
                        "            var outlineThickness = hoverTooltipData.getChild(\"outlineThickness\").getAsNumber();",
                        "            var outlineColor = hoverTooltipData.getChild(\"outlineColor\").getAsString();",
                        "            if (text != \"null\" && text != null) {",
                        "                var font = hoverTooltipData.getChild(\"font\").getAsString();",
                        "                var fontSize = hoverTooltipData.getChild(\"fontSize\").getAsNumber();",
                        "                if (font == \"0\") { font = null } // Leave as default if unset",
                        "                if (fontSize == 0) { fontSize = null }",
                        "                if (outlineColor == \"0\") { outlineColor = \"0;0;0\" }",
                        "                hoverTooltip = {",
                        "                    text: text,",
                        "                    x: hoverTooltipData.getChild(\"x\").getAsNumber(),",
                        "                    y: hoverTooltipData.getChild(\"y\").getAsNumber(),",
                        "                    font: font,",
                        "                    fontSize: fontSize,",
                        "                    bold: bold,",
                        "                    outlineThickness: outlineThickness,",
                        "                    //outlineColor: outlineColor",
                        "",
                        "                }",
                        "            }",
                        "        } else if (hoveredInstance.getName() in FDSG.Input.HoverTooltips) {",
                        "            hoverTooltip = FDSG.Input.HoverTooltips[hoveredInstance.getName()];",
                        "        }",
                        "        if (hoverTooltip != null) {",
                        "            const hoverTooltipObj = GameVars.runtimeScene.createObject(\"HoverTooltip\");",
                        "            hoverTooltipObj.setLayer(hoveredInstance.getLayer());",
                        "            hoverTooltipObj.setZOrder(99);",
                        "            hoverTooltipObj.setX(hoveredInstance.getX() + hoverTooltip.x);",
                        "            hoverTooltipObj.setY(hoveredInstance.getY() + hoverTooltip.y);",
                        "            hoverTooltipObj.setText(hoverTooltip.text);",
                        "            hoverTooltipObj.setOutlineThickness(hoverTooltipData.outlineThickness);",
                        "            //hoverTooltipObj.setOutlineColor(hoverTooltipData.outlineColor);",
                        "            if (hoverTooltip.font != null) { hoverTooltipObj.setFontName(hoverTooltip.font) }",
                        "            if (hoverTooltip.fontSize != null) { hoverTooltipObj.setCharacterSize(hoverTooltip.fontSize) }",
                        "            ",
                        "            linksManager.linkObjects(hoveredInstance, hoverTooltipObj); // Link the objects so we don't create more than one",
                        "        }",
                        "    }",
                        "}"
                      ],
                      "parameterObjects": "",
                      "useStrict": true,
                      "eventsSheetExpanded": true
                    }
                  ],
                  "parameters": []
                },
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "folded": true,
                  "name": "Inspections and Interactions",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::JsCode",
                      "inlineCode": [
                        "const FDSG = gdjs.FDGameData;",
                        "const GameVars = FDSG.GameVars;",
                        "const Game = GameVars.runtimeScene.getGame();",
                        "",
                        "/*",
                        "Inspections are just groups of objects that can be used as \"popups\", for when you want to introduce",
                        "new elements into the scene that don't really justify transitioning to a whole new scene. This is useful for item",
                        "popups, dialogue popups, really any time the player is focusing on something in the current layout",
                        "*/",
                        "",
                        "Object.assign(GameVars, {",
                        "    _loadedInspection: null, // Used to track which Inspection is currently loaded",
                        "    _isInspecting: false,",
                        "});",
                        "",
                        "Object.defineProperty(GameVars, 'isInspecting', {",
                        "    get() {",
                        "        return this._isInspecting;",
                        "    },",
                        "    set(value) {",
                        "        if (value && FDSG.PlayerInventory.isInventoryShowing) {",
                        "            FDSG.PlayerInventory.isInventoryShowing = false;",
                        "        }",
                        "        FDSG.darkEffect(value, true); // Activate/Deactivate the dark screen effect",
                        "        const inspectionLayer = GameVars.runtimeScene.getLayer(\"InspectionObjects\"); // Get the InspectionObjects layer",
                        "        const inspectionUILayer = GameVars.runtimeScene.getLayer(\"InspectionUI\");",
                        "        inspectionLayer.show(value); // Show/Hide the layers",
                        "        inspectionUILayer.show(value);",
                        "        FDSG.enableLayerClick([\"InspectionObjects\", \"InspectionUI\"], value); // Enable/Disable the relevant layers clicks",
                        "        FDSG.enableLayerClick([\"UI\", \"SceneObjects\"], !value);",
                        "        if (!value) {",
                        "            FDSG.clearInspectionFromView();",
                        "        } ",
                        "    }",
                        "});",
                        "",
                        "FDSG.Interactions = {}; // Where we store and register Interactions",
                        "/*",
                        "Interactions are just an easy way to easily and dynamically allow an InteractionObject (or other objects) to run different code",
                        "based on the value of its \"targetInteraction\" property and its flags/variables. All this really does is allow me to",
                        "avoid having to make a bunch of unique objects for every interaction.",
                        "!!! If you just want to load an inspection into view without any conditions or extra code, just use an Inspection instead !!!",
                        "*/",
                        "",
                        "",
                        "/**",
                        " * Gets an object containing all inspections in the current layout as well as their associated InstanceGroups",
                        " *      @returns {Object} An object containing every inspection in the layout and their associated InstanceGroup",
                        " */",
                        "FDSG.getLayoutInspections = function() {",
                        "    /*",
                        "        All we really do here is check the different \"targetInspection\" values of instances in the layout,",
                        "        and create a map tying each object instance to its associated inspection. Then we just register",
                        "        the initial x and y positions of the InstanceGroup in the layout so we can move them into the camera view when they activate,",
                        "        and move them back when they exit",
                        "    */",
                        "    const layoutInspections = {}; // Holds all inspections and their InstanceGroup",
                        "    const allInstances = FDSG.getAllSceneInstances(\"InspectionObjects\"); // Get all instances on the InspectionObjects layer",
                        "    const inspectionInstances = {}; // Temporary object to map inspections to their associated instances",
                        "    for (const instance of allInstances) {",
                        "        if (!instance.getVariables().has(\"inspectionName\")) { // Check if the instance is associated with an inspection",
                        "            continue;",
                        "        }",
                        "        const inspection = instance.getVariables().get(\"inspectionName\").getAsString();",
                        "        if (!(inspection in inspectionInstances)) {",
                        "            inspectionInstances[inspection] = []; // This will store the object instances tied to this inspection",
                        "        }",
                        "        inspectionInstances[inspection].push(instance); // Register this instance to its inspection",
                        "    }",
                        "    for (const inspection in inspectionInstances) { // Create an InstanceGroup for each inspection",
                        "        const inspectionGroup = new FDSG.Classes.InstanceGroup(inspectionInstances[inspection]); ",
                        "            // Create a new InstanceGroup (see class definition) of all object instances in this inspection",
                        "        layoutInspections[inspection] = { // Store the data for this inspection",
                        "            instanceGroup: inspectionGroup, // The InstanceGroup containing the object instances",
                        "            initialX: inspectionGroup.x, // Store intitial position so we can restore it later",
                        "            initialY: inspectionGroup.y",
                        "        }",
                        "    }",
                        "    return layoutInspections;",
                        "}",
                        "",
                        "",
                        "/**",
                        " * Sets the currentInspection and brings all associated objects into the camera view",
                        " *      @param {string} inspectionName The specific inspection to load objects from",
                        " *      @param {boolean} activateInspection? Whether to activate the inspection immediately. Defaults to true",
                        " */",
                        "FDSG.bringInspectionIntoView = function(inspectionName, activateInspection = true) {",
                        "    if (!(inspectionName in FDSG._LayoutInspections)) { // Check if the inspection is registered",
                        "        FDSG.debugPrint(`Inspection ${inspectionName} not registered`);",
                        "        return;",
                        "    }",
                        "    if (GameVars._loadedInspection != null) { ",
                        "        FDSG.clearInspectionFromView(); // Clear any currently loaded inspection",
                        "    }",
                        "    FDSG.debugPrint(`Loading inspection ${inspectionName}`);",
                        "    const cameraWidth = gdjs.evtTools.camera.getCameraWidth(GameVars.runtimeScene, \"\", 0); // Get camera properties to properly center Inspections",
                        "    const cameraHeight = gdjs.evtTools.camera.getCameraHeight(GameVars.runtimeScene, \"\", 0);",
                        "    const uiBackground = GameVars.runtimeScene.getInstancesOf(\"UIBackground\")[0];",
                        "    const cameraHeightOffset = uiBackground.getHeight() + uiBackground.getY(); // This is to vertically offset the inspection to make room for the UI",
                        "    const layoutInspectionData = FDSG._LayoutInspections[inspectionName];",
                        "    const inspectionGroup = layoutInspectionData.instanceGroup; // The InstanceGroup containing the instances of this inspection",
                        "    const activeX = (cameraWidth - inspectionGroup.width)/2; /* Calculate center screen position */",
                        "    const activeY = (cameraHeight + cameraHeightOffset - inspectionGroup.height)/2;",
                        "    inspectionGroup.moveTo(activeX, activeY); // Move the InstanceGroup to the center of the screen",
                        "    for (const instance of inspectionGroup.instances) { // Add rounded black edges to all images",
                        "        if (instance.getName() == \"InspectionImage\" && instance.getVariables().get(\"showBorder\").getAsBoolean()) {",
                        "            const imageBorder = GameVars.runtimeScene.createObject(\"InspectionImageBorder\"); // Create rounded corners for the image",
                        "            imageBorder.setLayer(instance.getLayer());",
                        "            imageBorder.setPosition(instance.getX(), instance.getY());",
                        "            imageBorder.setSize(instance.getWidth(), instance.getHeight());",
                        "            imageBorder.setZOrder(instance.getZOrder()+1);",
                        "        }",
                        "    }",
                        "    GameVars._loadedInspection = inspectionName;",
                        "    if (activateInspection) {",
                        "        GameVars.isInspecting = true;",
                        "    }",
                        "}",
                        "",
                        "",
                        "/**",
                        " * Clears the loaded inspection and resets its objects to their initial positions",
                        " */",
                        "FDSG.clearInspectionFromView = function() {",
                        "    if (GameVars._loadedInspection == null) { // Don't unload if no inspections are loaded",
                        "        FDSG.debugPrint(`No inspection loaded`);",
                        "        return;",
                        "    }",
                        "    FDSG.debugPrint(`Unloading inspection: ${GameVars._loadedInspection}`);",
                        "    const inspectionData = FDSG._LayoutInspections[GameVars._loadedInspection];",
                        "    const instanceGroup = inspectionData.instanceGroup;",
                        "    const initialX = inspectionData.initialX; // Get initial instance positions",
                        "    const initialY = inspectionData.initialY;",
                        "    instanceGroup.moveTo(initialX, initialY);",
                        "    for (const imageBorder of GameVars.runtimeScene.getInstancesOf(\"InspectionImageBorder\").slice()) {",
                        "        if (imageBorder.getLayer() == \"InspectionObjects\") {",
                        "            imageBorder.deleteFromScene(); // Clear all corners so they aren't duplicated",
                        "        }",
                        "    }",
                        "    GameVars._loadedInspection = null;",
                        "}",
                        "",
                        "/**",
                        " * Darkens the appropriate layers for pausing and inspection",
                        " *      @param {boolean} enable Whether to enable or disable the effect",
                        " *      @param {boolean} darkenUI Whether to darken the UI layer (for inspections) ",
                        " */",
                        "FDSG.darkEffect = function(enable, darkenUI = false) {",
                        "    const backgroundLayer = GameVars.runtimeScene.getLayer(\"Background\");",
                        "    const objectsLayer = GameVars.runtimeScene.getLayer(\"SceneObjects\");",
                        "    const uiLayer = GameVars.runtimeScene.getLayer(\"UI\");",
                        "    const layers = [backgroundLayer, objectsLayer];",
                        "    if (darkenUI) {",
                        "        layers.push(uiLayer);",
                        "    }",
                        "    for (const layer of layers) {",
                        "        layer.enableEffect(\"Darken\", enable);",
                        "    }",
                        "}",
                        "",
                        "",
                        "/**",
                        " * Registers an interaction to a given name",
                        " *      @param {string} interactionName The name of the interaction",
                        " *      @param {(obj: RuntimeObject) => void} interactionFunction The function that contains the code for this interaction",
                        " *      @param {boolean} runUsualFunction? Whether to run the objects usual functions as well as the interaction. Defaults to true",
                        " */",
                        "FDSG.registerInteraction = function(interactionName, interactionFunction, runUsualFunction = true) {",
                        "    FDSG.Interactions[interactionName] = {",
                        "        interactionFunction: interactionFunction,",
                        "        runUsual: runUsualFunction",
                        "    }",
                        "}"
                      ],
                      "parameterObjects": "",
                      "useStrict": true,
                      "eventsSheetExpanded": true
                    }
                  ],
                  "parameters": []
                },
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "folded": true,
                  "name": "Collectibles",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::JsCode",
                      "inlineCode": [
                        "const FDSG = gdjs.FDGameData;",
                        "const GameVars = FDSG.GameVars;",
                        "const Game = GameVars.runtimeScene.getGame();",
                        "",
                        "Object.assign(GameVars, {",
                        "    collectiblesFound: {}, /* This is used to track which collectibles have been collected. Each collectible has a uniqueID,",
                        "                        and is either true (collected) or false (not collected) */",
                        "    statuesCollected: 0, // The number of statues Collected",
                        "});",
                        "",
                        "",
                        "/**",
                        " * Removes a collectible object from the scene and marks it as collected.",
                        " *      @param {gdjs.RuntimeObject} collectible the collectibleObject that's being collected",
                        " *      @returns {boolean} If the object was successfully collected",
                        " */",
                        "FDSG.collectObject = function(collectible) {",
                        "    if (!FDSG.ObjectGroups.Collectibles.includes(String(collectible.getName()))) {",
                        "        FDSG.debugPrint(\"warn\", \"Object is not a collectible\");",
                        "        return false;",
                        "    }",
                        "    const uniqueID = `${collectible.name}-${GameVars.currentLayout}-${collectible.getX()}-${collectible.getY()}`;",
                        "        // The objects uniqueID to distinguish it from others",
                        "    GameVars.collectiblesFound[uniqueID] = true; // Mark as collected",
                        "    collectible.deleteFromScene(GameVars.runtimeScene);",
                        "    FDSG.debugPrint(`Collected ${uniqueID}`);",
                        "    return true;",
                        "}",
                        "",
                        "",
                        "/**",
                        " * Checks each collectible instance in the scene and removes it if it's been marked as collected already",
                        " */",
                        "FDSG.removeCollectedObjects = function() {",
                        "    for (const collectibleType of FDSG.ObjectGroups.Collectibles) { // Check all instances of collectible objects to see if they've been collected already",
                        "        const collectibleObjects = GameVars.runtimeScene.getInstancesOf(collectibleType).slice(); // Get copy of array to avoid iteration issues",
                        "        for (const collectible of collectibleObjects) {",
                        "            const uniqueID = `${collectible.name}-${GameVars.currentLayout}-${collectible.getX()}-${collectible.getY()}`;",
                        "                /* Each collectible instance is assigned to a unique ID that consists of the type of object, the name of the layout they're in,",
                        "                and their x and y coordinates. This way we can track which objects have been collected or not */",
                        "            if (uniqueID in GameVars.collectiblesFound) { // Check if this instance has been registered before",
                        "                if (GameVars.collectiblesFound[uniqueID] == true) { // Check if this item has been collected already",
                        "                    collectible.deleteFromScene(); // Remove the object from the scene",
                        "                }",
                        "            } else { // Collectible has not been registered before",
                        "                GameVars.collectiblesFound[uniqueID] = false; // register the object as not collected yet",
                        "            }",
                        "        }",
                        "    }",
                        "}",
                        "",
                        "",
                        "/**",
                        " * Sets the value of the StatuesCollectedCounter",
                        " */",
                        "FDSG.updateStatueCounter = function() {",
                        "    const statueCounter = GameVars.runtimeScene.getObjects(\"StatuesCollectedCounter\")[0];",
                        "    statueCounter.getVariables().get(\"value\").setNumber(GameVars.statuesCollected);",
                        "    statueCounter.setText(`: ${GameVars.statuesCollected}`);",
                        "}"
                      ],
                      "parameterObjects": "",
                      "useStrict": true,
                      "eventsSheetExpanded": true
                    }
                  ],
                  "parameters": []
                },
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "name": "Inventory and Items",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::JsCode",
                      "inlineCode": [
                        "const FDSG = gdjs.FDGameData;",
                        "const GameVars = FDSG.GameVars;",
                        "const Game = GameVars.runtimeScene.getGame();",
                        "",
                        "Object.assign(GameVars, {",
                        "    _isItemPopupShowing: false, // Whether the itemPopup is showing or not",
                        "    _itemPopupData: {",
                        "        itemObject: null, // The RuntimeObject of selected item",
                        "        inventoryItem: null, // The RuntimeObject for the item sprite",
                        "        itemNameText: null, // The RuntimeObject for the name text",
                        "        itemDescriptionText: null, // The RuntimeObject for the description text",
                        "        itemPickupButton: null, // Button to pick up item",
                        "        itemLeaveButton: null, // Button to leave item",
                        "    }",
                        "});",
                        "",
                        "Object.defineProperty(GameVars, \"isItemPopupShowing\", {",
                        "    get() { return this._isItemPopupShowing },",
                        "    set(isShowing) {",
                        "        // A lot of this code is pretty identical to how Inspections work, but I wanted to keep those systems separate",
                        "        const itemPopupLayer = GameVars.runtimeScene.getLayer(\"ItemPopup\"); // Get the ItemPopup layer",
                        "        const uiBackground = GameVars.runtimeScene.getInstancesOf(\"UIBackground\")[0];",
                        "        const cameraHeightOffset = uiBackground.getHeight() + uiBackground.getY(); // This is to vertically offset the inspection to make room for the UI",
                        "        FDSG.darkEffect(isShowing, true); // Activate/Deactivate the dark screen effect",
                        "        FDSG.enableLayerClick(\"ItemPopup\", isShowing); // Enable/Disable the relevant layers clicks",
                        "        FDSG.enableLayerClick([\"UI\", \"SceneObjects\"], !isShowing);",
                        "        FDSG.enableObjectClick(\"InventoryItem\", !isShowing); // Disable the object sprite from being clickable",
                        "        itemPopupLayer.show(isShowing); // Show/Hide the layer",
                        "    }",
                        "})",
                        "",
                        "",
                        "Object.assign(GameVars.Constants, {",
                        "    ITEM_CURSOR_X_OFFSET: 16, // How far displaced the selected item is from the cursor",
                        "    ITEM_CURSOR_Y_OFFSET: 16,",
                        "    ITEM_OFFSET: 8, // These change how the inventory is displayed",
                        "    ITEM_GAP: 8,",
                        "    ITEM_POPUP_SIZE: 224, // How large the item in the item popup should be",
                        "    INVENTORY_CLOSED_X_OFFSET: -8, // The X and Y positions of the inventory when open and closed, relative to the Backpack",
                        "    INVENTORY_CLOSED_Y_OFFSET: -32,",
                        "    INVENTORY_OPEN_X_OFFSET: -8, ",
                        "    INVENTORY_OPEN_Y_OFFSET: 67,",
                        "    ",
                        "    INVENTORY_TWEEN_DURATION: 500 // How long it should take for the inventory to open",
                        "});",
                        "",
                        "",
                        "FDSG.PlayerInventory = { // Stores data related to the player inventory",
                        "    itemData: [], // This stores the currently held items and their data",
                        "    _itemObjects: [], // This stores the InventoryItem Objects that represent the item in the player inventory",
                        "    _scrollIndex: 0, // The starting index for item scrolling",
                        "    _selectedItemData: null, // Which item is currently selected",
                        "        get selectedItem() {",
                        "            if (this._selectedItemData == null) {",
                        "                return null;",
                        "            } else {",
                        "                return this._selectedItemData.itemName;",
                        "            }",
                        "        },",
                        "        set selectedItem(value) {",
                        "            if (value == null) {",
                        "                FDSG.selectInventoryItem(null);",
                        "            }",
                        "            else {",
                        "                FDSG.debugPrint(\"warn\", 'Warning: Do not try and set selectedItem directly! Use selectedItemIndex to get the object instead');",
                        "                    // We need to know which instance to remove from the inventory, so setting the name directly is a bad idea",
                        "            }",
                        "        },",
                        "    _selectedItemIndex: null, // The inventory index of the currently selected item",
                        "        get selectedItemIndex() { return this._selectedItemIndex },",
                        "        set selectedItemIndex(index) {",
                        "            FDSG.debugPrint(\"log\", `selecting item index ${index}`);",
                        "            if (index < 0) {",
                        "                FDSG.debugPrint(\"warn\",'invalid inventory index');",
                        "            } else {",
                        "                FDSG.selectInventoryItem(index);",
                        "                this._selectedItemIndex = index;",
                        "            }",
                        "        },",
                        "    _isInventoryShowing: false, // Whether the inventory is currently showing",
                        "        get isInventoryShowing() { return this._isInventoryShowing},",
                        "        set isInventoryShowing(val) { ",
                        "            if (this._isInventoryShowing != val) { FDSG.showInventory(val) }",
                        "        }",
                        "}",
                        "",
                        "/**",
                        " * Redraws the inventory to show current items",
                        " */",
                        "FDSG.redrawInventory = function() {",
                        "    const inventory = FDSG.PlayerInventory;",
                        "    const inventoryObject = GameVars.runtimeScene.getObjects(\"InventoryBackground\")[0]; // Gets the InventoryUI object from the UI Layout",
                        "    const inventoryItemData = inventory.itemData; // Get the sprites of the items in the inventory",
                        "    for (const inventoryItem of inventory._itemObjects) {",
                        "        inventoryItem.deleteFromScene(); // Clear the inventory to draw the current items",
                        "    }",
                        "    inventory._itemObjects = [];",
                        "    const itemZOrder = inventoryObject.getZOrder() + 1;",
                        "    const inventoryShortSide = Math.min(inventoryObject.getWidth(), inventoryObject.getHeight());",
                        "    const inventoryLongSide = Math.max(inventoryObject.getWidth(), inventoryObject.getHeight());",
                        "    var itemSize = inventoryShortSide - 2*GameVars.Constants.ITEM_OFFSET; // The size to render item sprites",
                        "    const maxVisibleItems = Math.floor((inventoryLongSide-GameVars.Constants.ITEM_GAP)/(itemSize + GameVars.Constants.ITEM_GAP));",
                        "    const itemStartPosition = GameVars.Constants.ITEM_GAP + ((inventoryLongSide-GameVars.Constants.ITEM_GAP)%(itemSize + GameVars.Constants.ITEM_GAP))/2;",
                        "    if (inventoryObject.getWidth() > inventoryObject.getHeight()) {",
                        "        var itemPosX = inventoryObject.getX() + itemStartPosition;",
                        "        var itemXModifier = itemSize + GameVars.Constants.ITEM_GAP;",
                        "        var itemPosY = inventoryObject.getY() + GameVars.Constants.ITEM_OFFSET;",
                        "        var itemYModifier = 0;",
                        "    } else {",
                        "        var itemPosX = inventoryObject.getX() + GameVars.Constants.ITEM_OFFSET;",
                        "        var itemXModifier = 0;",
                        "        var itemPosY = inventoryObject.getY() + itemStartPosition;",
                        "        var itemYModifier = itemSize + GameVars.Constants.ITEM_GAP;",
                        "    }",
                        "    if (inventory.itemData.length < maxVisibleItems) {",
                        "        inventory._scrollIndex = Math.min(inventory._scrollIndex, maxVisibleItems-inventory.itemData.length);",
                        "    }",
                        "    FDSG.debugPrint(\"log\", `drawing inventory`);",
                        "    let inventoryShowing = FDSG.PlayerInventory.isInventoryShowing;",
                        "    for (let i = inventory._scrollIndex; i < Math.min(inventory.itemData.length+inventory._scrollIndex, maxVisibleItems+inventory._scrollIndex); i++) {",
                        "        // This iterates through each item in our inventory and generates an InventoryItem to represent it in the player inventory",
                        "        const currentItemData = inventory.itemData[i];",
                        "        const inventoryItemObject = GameVars.runtimeScene.createObject(\"InventoryItem\");",
                        "        inventoryItemObject.setAnimationName(currentItemData.itemName);",
                        "        inventoryItemObject.getVariables().get(\"itemName\").setString(currentItemData.itemName);",
                        "        inventoryItemObject.getVariables().get(\"inventoryIndex\").setNumber(i);",
                        "        const itemInitialHeight = inventoryItemObject.getHeight();",
                        "        const itemInitialWidth = inventoryItemObject.getWidth();",
                        "        const itemScale = (inventoryShortSide - 2*GameVars.Constants.ITEM_OFFSET)/itemInitialHeight;",
                        "        inventoryItemObject.setHeight(itemInitialHeight*itemScale);",
                        "        inventoryItemObject.setWidth(itemInitialWidth*itemScale);",
                        "        inventoryItemObject.setX(itemPosX);",
                        "        inventoryItemObject.setY(itemPosY);",
                        "        inventoryItemObject.setLayer(\"InventoryUI\");",
                        "        inventoryItemObject.setZOrder(itemZOrder);",
                        "        inventoryItemObject.getVariables().get(\"enabled\").setBoolean(inventoryShowing)",
                        "",
                        "        inventory._itemObjects.push(inventoryItemObject);",
                        "",
                        "        itemPosX += itemXModifier;",
                        "        itemPosY += itemYModifier;",
                        "    }",
                        "",
                        "    const scrollArrowP = GameVars.runtimeScene.getObjects(\"CycleInventoryPrevious\")[0];",
                        "    const scrollArrowN = GameVars.runtimeScene.getObjects(\"CycleInventoryNext\")[0];",
                        "    var enableP = false;",
                        "    var enableN = false;",
                        "    if (inventory._scrollIndex > 0) {",
                        "        enableP = true;",
                        "    }",
                        "    scrollArrowP.enableEffect(\"Disable\", !enableP);",
                        "    FDSG.enableObjectClick(\"CycleInventoryPrevious\", enableP);",
                        "    if (inventory.itemData.length > maxVisibleItems + inventory._scrollIndex) {",
                        "        enableN = true;",
                        "    }",
                        "    scrollArrowN.enableEffect(\"Disable\", !enableN);",
                        "    FDSG.enableObjectClick(\"CycleInventoryNext\", enableN);",
                        "}",
                        "",
                        "",
                        "/**",
                        " * Shows the item popup for a given item",
                        " *      @param {string} itemName The name of the item",
                        " *      @param {string} itemDescription? The description of the item. Defaults to null for hiding the popup",
                        " *      @param {boolean} canPickup? Whether the button to pick up the item should show. We disable this if players are",
                        " *                                  just inspecting an item in their inventory. Defaults to true",
                        " */",
                        "FDSG.showItemPopup = function(itemName, itemDescription, canPickup = true) {",
                        "    const itemPopupData = GameVars._itemPopupData;",
                        "    for (const instance of FDSG.getAllSceneInstances(\"ItemPopup\")) { // Assign references to the right objects",
                        "        switch(instance.getName()) {",
                        "            case(\"InventoryItem\"):",
                        "                itemPopupData.inventoryItem  = instance;",
                        "                break;",
                        "            case(\"ItemNameText\"):",
                        "                itemPopupData.itemNameText = instance;",
                        "                break;",
                        "            case(\"ItemDescriptionText\"):",
                        "                itemPopupData.itemDescriptionText = instance;",
                        "                break;",
                        "            case(\"ItemPopupPickupButton\"):",
                        "                itemPopupData.itemPickupButton = instance;",
                        "                break;",
                        "            case(\"ItemPopupExitButton\"):",
                        "                itemPopupData.itemExitButton = instance;",
                        "                break;",
                        "        }",
                        "    }",
                        "    const itemObject = FDSG.GameVars._itemPopupData.itemObject; // Get the original item object",
                        "    // console.log(itemObject);",
                        "    const inventoryItem = itemPopupData.inventoryItem; // Get the instance of the InventoryItem used for the popup sprite",
                        "    const previousAnim = inventoryItem.getAnimation(); // Used to check if the given animation is valid",
                        "    inventoryItem.setAnimationName(itemName); // Set the sprite",
                        "    if (previousAnim != 0 && inventoryItem.getAnimation() == previousAnim) {",
                        "        FDSG.debugPrint(\"warn\",`invalid animation for item: ${itemName}`);",
                        "    }",
                        "    inventoryItem.setWidth(GameVars.Constants.ITEM_POPUP_SIZE); // Resize the sprite to fit the popup",
                        "    inventoryItem.setHeight(GameVars.Constants.ITEM_POPUP_SIZE);",
                        "    itemPopupData.itemNameText.setText(itemName); // Set the text to the item name",
                        "    itemPopupData.itemDescriptionText.setText(itemDescription);",
                        "    const pickupButton = itemPopupData.itemPickupButton;",
                        "    const leaveButton = itemPopupData.itemExitButton;",
                        "    if (!canPickup) { // If we're inspecting an item already in the inventory, we display things a little different",
                        "        pickupButton.hide(true); // Can't pick up an item already in your inventory",
                        "        pickupButton.getVariables().get(\"enabled\").setBoolean(false);",
                        "        leaveButton.setZOrder(pickupButton.getZOrder()+1);",
                        "        leaveButton.setX(512); // Move the \"leave\" button to the center of the screen",
                        "    } else {",
                        "        pickupButton.hide(false);",
                        "        pickupButton.getVariables().get(\"enabled\").setBoolean(true);",
                        "        leaveButton.setX(720); // Move the \"leave\" button to the center of the screen",
                        "    }",
                        "    GameVars.isItemPopupShowing = true;",
                        "}",
                        "",
                        "",
                        "/**",
                        " * Add an item to the player inventory and redraw it",
                        " *      @param {string} itemName The name of the item to add",
                        " *      @param {string} itemDescription The description of the item being added",
                        " *      @param {Object} animationData Data for playing the tween backpack animation. Defaults to null for no animation",
                        " */",
                        "FDSG.addItemToInventory = function(itemName, itemDescription, animationData = null) {",
                        "    FDSG.debugPrint(\"log\",`Adding ${itemName} to inventory`);",
                        "    const itemData = { // Holds all the item information",
                        "        itemName: itemName, // The item name",
                        "        itemDescription: itemDescription, // The item description",
                        "    }",
                        "    FDSG.PlayerInventory.itemData.push(itemData);",
                        "    if (animationData) {",
                        "        FDSG.playItemCollectionAnimation(animationData);",
                        "    }",
                        "    FDSG.redrawInventory();",
                        "    FDSG.showInventory(true);",
                        "}",
                        "",
                        "/**",
                        " * Remove an item to the player inventory",
                        " *      @param {string} itemName The name of the item to add",
                        " */",
                        "FDSG.removeItemFromInventory = function(inventoryIndex) {",
                        "    const inventory = FDSG.PlayerInventory;",
                        "    FDSG.debugPrint(\"log\",`Removing ${inventory.itemData[inventoryIndex].itemName} from inventory`);",
                        "    inventory.itemData.splice(inventoryIndex, 1);",
                        "    if (inventory._scrollIndex >= inventory.itemData.length) {",
                        "        inventory._scrollIndex -= 1;",
                        "    }",
                        "    FDSG.redrawInventory();",
                        "}",
                        "",
                        "/**",
                        " * Check if an item is in the players inventory",
                        " *      @param {string} itemName The name of the item to look for",
                        " *      @returns {number} How many of the given item are currently in the player inventory",
                        " */",
                        "",
                        "FDSG.isItemInInventory = function(itemName) {",
                        "    const numItemInInventory = 0; // How many of the given item are in the players inventory",
                        "    for (const itemData of FDSG.PlayerInventory.itemData) {",
                        "        if (itemData.itemName == itemName) {",
                        "            numItemInInventory += 1;",
                        "        }",
                        "    }",
                        "    return numItemInInventory;",
                        "",
                        "}",
                        "",
                        "/**",
                        " * Select an item from the inventory",
                        " *      @param {number} inventoryIndex The index of the inventoryItem being selected",
                        " */",
                        "FDSG.selectInventoryItem = function(inventoryIndex) {",
                        "    const inventory = FDSG.PlayerInventory;",
                        "    if (inventoryIndex < 0) {",
                        "        FDSG.debugPrint(\"warn\",\"invalid inventoryIndex\");",
                        "        return;",
                        "    }",
                        "    const selectionBorderExists = GameVars.runtimeScene.getInstancesOf(\"SelectedItemBorder\");",
                        "    const itemCursorExists = FDSG.getAllSceneInstances(\"MouseCursor\");",
                        "    const inspectInventoryItem = GameVars.runtimeScene.getInstancesOf(\"InspectInventoryItem\")[0];",
                        "    // Clear any previous instances",
                        "    if (selectionBorderExists.length > 0) {",
                        "        for (const instance of selectionBorderExists.slice()) {",
                        "            instance.deleteFromScene();",
                        "        }",
                        "    }",
                        "    if (itemCursorExists.length > 0) {",
                        "        for (const instance of itemCursorExists.slice()) {",
                        "            instance.deleteFromScene();",
                        "        }",
                        "    }",
                        "    if (inventoryIndex == null) {",
                        "        inventory._selectedItemData = null;",
                        "        inventory._selectedItemIndex = null;",
                        "        inspectInventoryItem.enableEffect(\"Disable\", true); // Hide the itemInspectButton",
                        "        inspectInventoryItem.getVariables().get(\"enabled\").setBoolean(false);",
                        "        return;",
                        "    }",
                        "    const inventoryItemObject = inventory._itemObjects[inventoryIndex];",
                        "    const selectionBorder = GameVars.runtimeScene.createObject(\"SelectedItemBorder\");",
                        "    selectionBorder.setLayer(\"UI\");",
                        "    selectionBorder.setZOrder(50);",
                        "    selectionBorder.setWidth(inventoryItemObject.getWidth());",
                        "    selectionBorder.setHeight(inventoryItemObject.getHeight());",
                        "    selectionBorder.setX(inventoryItemObject.getX());",
                        "    selectionBorder.setY(inventoryItemObject.getY());",
                        "    // The InspectInventoryItem button lets the player view the item description of the currently selected item",
                        "    inspectInventoryItem.enableEffect(\"Disable\", false); // Show the itemInspectButton",
                        "    inspectInventoryItem.getVariables().get(\"enabled\").setBoolean(true);",
                        "",
                        "    const canTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0; // Check if device has touchscreen compatibility",
                        "    if (!canTouch) { // This doesn't work well with touchscreens, so we disable it if the player is using one",
                        "        FDSG.Input._deviceSupportsTouch = false;",
                        "        const itemCursor = GameVars.runtimeScene.createObject(\"InventoryItem\");",
                        "        itemCursor.setLayer(\"MouseCursor\");",
                        "        itemCursor.getVariables().get(\"isCursor\").setBoolean(true);",
                        "        itemCursor.setAnimationIndex(inventoryItemObject.getAnimationIndex());",
                        "        itemCursor.setWidth(inventoryItemObject.getWidth()/1.5);",
                        "        itemCursor.setHeight(inventoryItemObject.getHeight()/1.5);",
                        "        itemCursor.setX(gdjs.evtTools.input.getCursorX(GameVars.runtimeScene) + 16); // Make the itemCursor follow the mouse;",
                        "        itemCursor.setY(gdjs.evtTools.input.getCursorY(GameVars.runtimeScene) + 16); // Make the itemCursor follow the mouse;",
                        "    } else {",
                        "        FDSG.Input._deviceSupportsTouch = true;",
                        "    }",
                        "    FDSG.PlayerInventory._selectedItemData = FDSG.PlayerInventory.itemData[inventoryIndex];",
                        "}",
                        "",
                        "/**",
                        " * Shows or hides the inventory, sliding it into or out of view",
                        " *      @param {boolean} show Whether to show or hide the inventory",
                        " */",
                        "FDSG.showInventory = function(show) {",
                        "    FDSG.debugPrint(\"log\",\"showing inventory:\", show);",
                        "    const inventory = FDSG.PlayerInventory;",
                        "    const inventoryInstances = FDSG.getAllSceneInstances(\"InventoryUI\");",
                        "    const inventoryUILayer = GameVars.runtimeScene.getLayer(\"InventoryUI\");",
                        "    const inventoryUIBackground = GameVars.runtimeScene.getInstancesOf(\"InventoryUIBackground\")[0];",
                        "    const backpack = GameVars.runtimeScene.getInstancesOf(\"Backpack\")[0];",
                        "    let targetYOffset = 0; // Where the objects will tween to, relative to their current position",
                        "    let targetX = null; // Where the inventory is tweening to",
                        "    let targetY = null;",
                        "    let duration = GameVars.Constants.INVENTORY_TWEEN_DURATION;",
                        "    if (show) {",
                        "        targetX = backpack.getX() + GameVars.Constants.INVENTORY_OPEN_X_OFFSET;",
                        "        targetY = backpack.getY() + GameVars.Constants.INVENTORY_OPEN_Y_OFFSET;",
                        "    } else {",
                        "        targetX = backpack.getX() + GameVars.Constants.INVENTORY_CLOSED_X_OFFSET;",
                        "        targetY = backpack.getY() + GameVars.Constants.INVENTORY_CLOSED_Y_OFFSET;",
                        "    }",
                        "    FDSG.debugPrint(\"log\",`initiating inventory object tween`);",
                        "    for (const instance of inventoryInstances) {",
                        "        let tween = instance.getBehavior(\"Tween\");",
                        "        if (tween.isPlaying(\"inventoryTween\")) {",
                        "            FDSG.debugPrint(\"log\",\"cancelling object tween\");",
                        "            tween.removeTween(\"inventoryTween\");",
                        "        }",
                        "        let relativeX = instance.getX() - inventoryUIBackground.getX();",
                        "        let relativeY = instance.getY() - inventoryUIBackground.getY();",
                        "        tween.addObjectPositionTween(\"inventoryTween\", targetX + relativeX, targetY + relativeY,\"easeFromTo\", duration, false);",
                        "        if (instance.getName() != \"InspectInventoryItem\") {",
                        "            instance.getVariables().get(\"enabled\").setBoolean(show);",
                        "",
                        "        }",
                        "    }",
                        "    inventory._isInventoryShowing = show;",
                        "}",
                        "",
                        "",
                        "/**",
                        " * Plays the animation of an item floating into the backpack",
                        " *      @param {Object} itemData An object with the necessary data",
                        " *      @param {string} itemData.itemImageName The animation name of the items sprite",
                        " *      @param {number} itemData.fromX X position to start the animation from",
                        " *      @param {number} itemData.fromY Y position to start the animation from",
                        " *      @param {number} itemData.startWidth The initial width of the animating item",
                        " *      @param {number} itemData.startHeight The initial height of the animating item",
                        " *      @param {number} itemData.toX? The target X position of the animation. Defaults to the backpacks position",
                        " *      @param {number} itemData.toY? The target Y position of the animation. Defaults to the backpacks position ",
                        " *      @param {number} itemData.targetXScale? The final Y scale of the animating item. Defaults to 0",
                        " *      @param {number} itemData.targetYScale? The final X scale of the animating item. Defaults to 0     ",
                        " */",
                        "FDSG.playItemCollectionAnimation = function(itemData) {",
                        "    const backpack = GameVars.runtimeScene.getInstancesOf(\"Backpack\")[0];",
                        "    const fromX = itemData.fromX;",
                        "    const fromY = itemData.fromY;",
                        "    const fromWidth = itemData.startWidth;",
                        "    const fromHeight = itemData.startHeight;",
                        "    const animItem = GameVars.runtimeScene.createObject(\"InventoryItem\");",
                        "    animItem.getVariables().get(\"enabled\").setBoolean(false);",
                        "    animItem.setLayer(\"UI\");",
                        "    animItem.setWidth(fromWidth);",
                        "    animItem.setHeight(fromHeight);",
                        "    animItem.setX(fromX);",
                        "    animItem.setY(fromY);",
                        "    animItem.setAnimationName(itemData.itemImageName);",
                        "    let targetX = backpack.getX() + backpack.getCenterX();",
                        "    let targetY = backpack.getY() + backpack.getCenterY();",
                        "    let targetXScale = 0;",
                        "    let targetYScale = 0;",
                        "    if (\"toX\" in itemData) { targetX = itemData.toX }",
                        "    if (\"toY\" in itemData) { targetY = itemData.toY }",
                        "    if (\"targetXScale\" in itemData) { targetWidth = itemData.targetXScale }",
                        "    if (\"targetYScale\" in itemData) { targetHeight = itemData.targetYScale }",
                        "    let tween = animItem.getBehavior(\"Tween\");",
                        "    tween.addObjectPositionTween(\"collectPositionTween\", targetX, targetY, \"linear\", 750, true);",
                        "    tween.addObjectScaleTween(\"collectScaleTween\", targetXScale, targetYScale, \"linear\", 1000, false, true);",
                        "}",
                        "",
                        ""
                      ],
                      "parameterObjects": "",
                      "useStrict": true,
                      "eventsSheetExpanded": true
                    }
                  ],
                  "parameters": []
                },
                {
                  "colorB": 228,
                  "colorG": 176,
                  "colorR": 74,
                  "creationTime": 0,
                  "folded": true,
                  "name": "Map and Location Groups",
                  "source": "",
                  "type": "BuiltinCommonInstructions::Group",
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::JsCode",
                      "inlineCode": [
                        "const FDSG = gdjs.FDGameData;",
                        "const GameVars = FDSG.GameVars;",
                        "",
                        "",
                        "/*",
                        "Here's where we define MapLocations for use with the Map feature. Each location is defined with the location name as a key,",
                        "with an array containing the names of all associated Layouts. The first layout in the array will always be the one loaded when",
                        "teleporting to this location using the in-game map",
                        "*/",
                        "FDSG.MapLocations = {",
                        "    ",
                        "}"
                      ],
                      "parameterObjects": "",
                      "useStrict": true,
                      "eventsSheetExpanded": false
                    }
                  ],
                  "parameters": []
                }
              ],
              "parameters": []
            },
            {
              "colorB": 228,
              "colorG": 176,
              "colorR": 74,
              "creationTime": 0,
              "name": "Clickable Object Registration",
              "source": "",
              "type": "BuiltinCommonInstructions::Group",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const FDSG = gdjs.FDGameData;",
                    "const GameVars = FDSG.GameVars;",
                    "const Game = GameVars.runtimeScene.getGame();",
                    "",
                    "",
                    "// CLICKABLE OBJECT REGISTRATIONS ##########################################################################################################################",
                    "/*",
                    "This is where you can easily assign objects to specific functions when clicked.",
                    "There are a lot of optional parameters you can pass, so don't be overwhelmed by the amount of text",
                    "Just call the FDSG.registerClickableObject() function, passing a clickConfig object with the following properties:",
                    "    clickConfig = {",
                    "        object|object[]: The type of scene object you're registering",
                    "        duration|duration[]: Whether the function should run as long as the mouse button is held down or just when released",
                    "        clickFunction: The function that should run when this object is clicked, with a parameter 'obj' for the instance being clicked.",
                    "            It's best to pass an anonymous function of this form: (obj) => {<insert code here>}",
                    "        cursor?: If you want the mouse cursor to change when hovering over this object, put it here as a string (defaults to \"pointer\")",
                    "        hoverFunction?: If you want a function to run when hovering over the object, put it here with (obj) as a parameter for the hovered instance",
                    "        hoverEffect?: Optional effect to play on the object when hovering over with the mouse.",
                    "                If you don't know what to put here, create the desired effect in the editor",
                    "                and then use the \"copy effects\" button. If you paste as text,",
                    "                the object you want will be the \"serialized effect\" object.",
                    "        hoverTooltip: If you want text to display when hovering over the object, put it in an object with the following structure:",
                    "            hoverTooltip = {",
                    "                x: Which x coordinate to display the object (relative to the parent object)",
                    "                y: Which y coordinate to display the object (relative to the parent object),",
                    "                font: What font to use",
                    "                fontSize: how large the text should be",
                    "                text: The text you want to display",
                    "            }",
                    "            You can also just give a specific instance a \"hoverTooltip\" structure variable with the same properties",
                    "    }",
                    "*/",
                    "",
                    "const outlineHoverEffect = { // This is a commonly used effect so its easier to define it here and use copies",
                    "        effectType:\"Outline\",",
                    "        name:\"hoverEffect\",",
                    "        doubleParameters: { padding: 0, thickness: 4 },",
                    "        stringParameters: { color: \"255;255;255\" }",
                    "    }",
                    "",
                    "",
                    "FDSG.registerClickableObject({",
                    "    object: \"TransitionObject\",",
                    "    duration: \"released\",",
                    "    clickFunction: (obj) => {",
                    "        GameVars.currentLayout = obj.getVariables().get(\"targetLayout\").getAsString();",
                    "            // Changes the currentLayout to the layout associated with the TransitionObject and reloads the scene",
                    "    },",
                    "    hoverEffect: structuredClone(outlineHoverEffect)",
                    "});",
                    "",
                    "FDSG.registerClickableObject({",
                    "    object: \"InteractionObject\",",
                    "    duration: \"released\",",
                    "    clickFunction: (obj) => {",
                    "        const targetInteraction = obj.getVariables().get(\"targetInteraction\").getAsString();",
                    "        if (targetInteraction in FDSG.Interactions) {",
                    "            FDSG.Interactions[targetInteraction].interactionFunction(obj); // Run the interaction",
                    "        } else {",
                    "            FDSG.debugPrint(\"warn\",`interaction ${targetInteraction} not registered`);",
                    "        }",
                    "    },",
                    "    cursor: \"help\",",
                    "    hoverEffect: structuredClone(outlineHoverEffect)",
                    "});",
                    "",
                    "FDSG.registerClickableObject({ // Similar to InteractionObject, but only for inspections",
                    "    object: \"InspectionObject\",",
                    "    duration: \"released\",",
                    "    clickFunction: (obj) => {",
                    "        const targetInspection = obj.getVariables().get(\"targetInspection\").getAsString();",
                    "        FDSG.bringInspectionIntoView(targetInspection);",
                    "        GameVars.isInspecting = true;",
                    "    },",
                    "    cursor: \"help\",",
                    "    hoverEffect: structuredClone(outlineHoverEffect)",
                    "});",
                    "",
                    "FDSG.registerClickableObject({",
                    "    object: \"ExitInspection\",",
                    "    duration: \"released\",",
                    "    clickFunction: (obj) => {",
                    "        GameVars.isInspecting = false;",
                    "    },",
                    "    hoverEffect: structuredClone(outlineHoverEffect)",
                    "});",
                    "",
                    "FDSG.registerClickableObject({",
                    "    object: \"StatueCollectible\",",
                    "    duration: \"released\",",
                    "    clickFunction: (obj) => {",
                    "        const objVariables = obj.getVariables();",
                    "        const itemName = objVariables.get(\"itemName\").getAsString();",
                    "        const itemDescription = objVariables.get(\"itemDescription\").getAsString();",
                    "        GameVars._itemPopupData.itemObject = obj;",
                    "        FDSG.showItemPopup(itemName, itemDescription);",
                    "    },",
                    "    hoverEffect: structuredClone(outlineHoverEffect)",
                    "});",
                    "",
                    "FDSG.registerClickableObject({",
                    "    object: \"ItemObject\",",
                    "    duration: \"released\",",
                    "    clickFunction: (obj) => {",
                    "        const objVariables = obj.getVariables();",
                    "        const itemName = objVariables.get(\"itemName\").getAsString();",
                    "        const itemDescription = objVariables.get(\"itemDescription\").getAsString();",
                    "        const showPopup = objVariables.get(\"showPickupPrompt\").getAsBoolean();",
                    "        const removeOnPickup = objVariables.get(\"removeOnPickup\").getAsBoolean();",
                    "        if (showPopup) {",
                    "            GameVars._itemPopupData.itemObject = obj;",
                    "            FDSG.showItemPopup(itemName, itemDescription);",
                    "        } else {",
                    "            FDSG.addItemToInventory(itemName, itemDescription);",
                    "            if (removeOnPickup) {",
                    "                FDSG.collectObject(obj);",
                    "            }",
                    "        }",
                    "    },",
                    "    hoverEffect: structuredClone(outlineHoverEffect)",
                    "});",
                    "",
                    "FDSG.registerClickableObject({",
                    "    object: \"Backpack\",",
                    "    duration: \"released\",",
                    "    clickFunction: (obj) => {",
                    "        let inventoryShowing = FDSG.PlayerInventory._isInventoryShowing;",
                    "        FDSG.showInventory(!inventoryShowing);",
                    "    },",
                    "    hoverEffect: structuredClone(outlineHoverEffect)",
                    "});",
                    "",
                    "FDSG.registerClickableObject({",
                    "    object: \"InventoryItem\",",
                    "    duration: \"released\",",
                    "    clickFunction: (obj) => {",
                    "        const itemInventoryIndex = obj.getVariables().get(\"inventoryIndex\").getAsNumber();",
                    "        FDSG.PlayerInventory.selectedItemIndex = itemInventoryIndex;",
                    "    },",
                    "    hoverEffect: structuredClone(outlineHoverEffect)",
                    "});",
                    "",
                    "FDSG.registerClickableObject({",
                    "    object: \"CycleInventoryNext\",",
                    "    duration: \"released\",",
                    "    clickFunction: (obj) => {",
                    "        FDSG.PlayerInventory._scrollIndex += 1;",
                    "        FDSG.redrawInventory();",
                    "    },",
                    "    hoverEffect: structuredClone(outlineHoverEffect)",
                    "});",
                    "",
                    "FDSG.registerClickableObject({",
                    "    object: \"CycleInventoryPrevious\",",
                    "    duration: \"released\",",
                    "    clickFunction: (obj) => {",
                    "        FDSG.PlayerInventory._scrollIndex -= 1;",
                    "        FDSG.redrawInventory();",
                    "    },",
                    "    hoverEffect: structuredClone(outlineHoverEffect)",
                    "});",
                    "",
                    "FDSG.registerClickableObject({",
                    "    object: \"InspectInventoryItem\",",
                    "    duration: \"released\",",
                    "    clickFunction: (obj) => {",
                    "        const inventory = FDSG.PlayerInventory;",
                    "        const itemName = inventory._selectedItemData.itemName;",
                    "        const itemDescription = inventory._selectedItemData.itemDescription;",
                    "        FDSG.showItemPopup(itemName, itemDescription, false);",
                    "        inventory.selectedItem = null;",
                    "    },",
                    "    hoverEffect: structuredClone(outlineHoverEffect)",
                    "});",
                    "",
                    "FDSG.registerClickableObject({",
                    "    object: \"ItemPopupPickupButton\",",
                    "    duration: \"released\",",
                    "    clickFunction: (obj) => {",
                    "        const itemPopupData = GameVars._itemPopupData;",
                    "        const itemName = itemPopupData.itemObject.getVariables().get(\"itemName\").getAsString();",
                    "        const itemDescription = itemPopupData.itemDescriptionText.getString();",
                    "        // const animationData = {",
                    "        //     itemImageName: itemName,",
                    "        //     fromX: itemPopupData.itemObject.getX(),",
                    "        //     fromY: itemPopupData.itemObject.getY(),",
                    "        //     startWidth: itemPopupData.itemObject.getWidth(),",
                    "        //     startHeight: itemPopupData.itemObject.getHeight(),",
                    "        // }",
                    "        if (itemPopupData.itemObject.getName() == \"StatueCollectible\") { // If the item is a figurine (statue)",
                    "            FDSG.GameVars.statuesCollected += 1; // Increase statues collected counter",
                    "            FDSG.updateStatueCounter();",
                    "            // const statueIcon = GameVars.runtimeScene.getInstancesOf(\"StatueIcon\")[0];",
                    "            // animationData.toX = statueIcon.getX() + statueIcon.getCenterX();",
                    "            // animationData.toY = statueIcon.getY() + statueIcon.getCenterY();",
                    "            // FDSG.playItemCollectionAnimation(animationData);",
                    "            FDSG.collectObject(itemPopupData.itemObject);",
                    "        } else {",
                    "            FDSG.addItemToInventory(itemName, itemDescription); // Add the item to inventory",
                    "            if (itemPopupData.itemObject.getVariables().get(\"removeOnPickup\").getAsBoolean()) {",
                    "                FDSG.collectObject(itemPopupData.itemObject);",
                    "            }",
                    "        }",
                    "        GameVars.isItemPopupShowing = false; // Hide the item popup",
                    "    },",
                    "    hoverEffect: structuredClone(outlineHoverEffect)",
                    "});",
                    "",
                    "FDSG.registerClickableObject({",
                    "    object: \"ItemPopupExitButton\",",
                    "    duration: \"released\",",
                    "    clickFunction: (obj) => {",
                    "        GameVars.isItemPopupShowing = false; // Hide the itemPopup",
                    "    },",
                    "    hoverEffect: structuredClone(outlineHoverEffect)",
                    "});",
                    "",
                    "FDSG.registerClickableObject({",
                    "    object: \"InteractionButton\",",
                    "    duration: \"released\",",
                    "    clickFunction: (obj) => {",
                    "        const targetInteraction = obj.getVariables().get(\"targetInteraction\").getAsString();",
                    "        if (targetInteraction in FDSG.Interactions) {",
                    "            FDSG.Interactions[targetInteraction].interactionFunction(obj); // Run the interaction",
                    "        } else {",
                    "            FDSG.debugPrint(\"warn\",`interaction ${targetInteraction} not registered`);",
                    "        }",
                    "    },",
                    "    hoverEffect: structuredClone(outlineHoverEffect)",
                    "});",
                    ""
                  ],
                  "parameterObjects": "",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": []
            },
            {
              "colorB": 228,
              "colorG": 176,
              "colorR": 74,
              "creationTime": 0,
              "folded": true,
              "name": "Interaction Registration",
              "source": "",
              "type": "BuiltinCommonInstructions::Group",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const FDSG = gdjs.FDGameData;",
                    "const GameVars = FDSG.GameVars;",
                    "const Game = GameVars.runtimeScene.getGame();",
                    "",
                    "// INTERACTIONS ############################################################################################################################################",
                    "/*",
                    "Interactions are just an easy way to easily and dynamically allow an InteractionObject (or other objects) to run different code",
                    "based on the value of its \"targetInteraction\" property and its flags/variables. All this really does is allow me to",
                    "avoid having to make a bunch of unique objects for every interaction.",
                    "!!! If you just want to load an inspection into view without any conditions or extra code, just use an Inspection instead !!!",
                    "*/",
                    "",
                    "function getFlag(obj, flagName, type = null) { // Just a helper function for getting instance flags, since it's going to be pretty common",
                    "    const flag = obj.getVariables().get(\"flags\").getChild(flagName);",
                    "    if (type == null) {",
                    "        return flag;",
                    "    }",
                    "    switch (type) {",
                    "        case(\"boolean\"):",
                    "            return flag.getAsBoolean();",
                    "            break;",
                    "        case(\"string\"):",
                    "            return flag.getAsString();",
                    "            break;",
                    "        case(\"number\"):",
                    "            return flag.getAsNumber();",
                    "    }",
                    "}",
                    "",
                    "",
                    "// Player tries to open chest in FDS North",
                    "FDSG.registerInteraction(\"FDS North Chest\", (obj) => {",
                    "    if (obj.getVariables().get(\"instanceID\").getAsString() == \"FDS North Chest\") { // Check if the player clicked the chest or the statue",
                    "        const isClosed = getFlag(obj, \"isClosed\", \"boolean\");",
                    "        if (isClosed) {",
                    "            if (FDSG.PlayerInventory.selectedItem != \"Key\") {",
                    "                FDSG.bringInspectionIntoView(\"closedChest\");",
                    "            } else {",
                    "                getFlag(obj, \"isClosed\").setBoolean(false);",
                    "                obj.setAnimationName(\"ChestOpen\");",
                    "                const keyIndex = FDSG.PlayerInventory.selectedItemIndex;",
                    "                FDSG.PlayerInventory.selectedItem = null;",
                    "                FDSG.removeItemFromInventory(keyIndex);",
                    "                FDSG.bringInspectionIntoView(\"openChest\");",
                    "            }",
                    "        } else {",
                    "            const isStatueCollected = getFlag(obj, \"statueCollected\", \"boolean\");",
                    "            if (!isStatueCollected) {",
                    "                FDSG.bringInspectionIntoView(\"openChest\");",
                    "            } else {",
                    "                FDSG.bringInspectionIntoView(\"emptyChest\");",
                    "            }",
                    "        }",
                    "    } else {",
                    "        const chest = FDSG.getInstanceFromID(\"FDS North Chest\");",
                    "        getFlag(chest, \"statueCollected\").setBoolean(true);",
                    "        FDSG.isInspecting = false;",
                    "    }",
                    "});",
                    "",
                    "",
                    "FDSG.registerInteraction(\"quoteMinigame\", (obj) => {",
                    "    const instanceID = obj.getVariables().get(\"instanceID\").getAsString();",
                    "    if (instanceID == \"librarian\") {",
                    "        const quoteMinigameFlag = GameVars.runtimeScene.getGame().getVariables().get(\"MinigameFlags\").getChild(\"Fill In The Quote\").getAsBoolean();",
                    "        if (quoteMinigameFlag) {",
                    "            FDSG.bringInspectionIntoView(\"winQuoteMinigame\");",
                    "        } else {",
                    "            FDSG.bringInspectionIntoView(\"librarian\");",
                    "        }",
                    "    } else if (instanceID == \"quoteButton\") {",
                    "        GameVars.isInspecting = false;",
                    "        FDSG.loadMinigame(\"Fill In The Quote\");",
                    "    } else if (instanceID == \"quoteStatue\") {",
                    "        let librarian = FDSG.getInstanceFromID(\"librarian\");",
                    "        librarian.getVariables().get(\"enabled\").setBoolean(false);",
                    "    }   ",
                    "}, true);"
                  ],
                  "parameterObjects": "",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": []
            },
            {
              "colorB": 228,
              "colorG": 176,
              "colorR": 74,
              "creationTime": 0,
              "folded": true,
              "name": "On Returning from Minigame",
              "source": "",
              "type": "BuiltinCommonInstructions::Group",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const FDSG = gdjs.FDGameData;",
                    "const GameVars = FDSG.GameVars;",
                    "",
                    "/*",
                    "    Here's where you can easily register code to run when returning from a minigame. Check the MinigameFlags Global Variable",
                    "    to determine whether a minigame was flagged as completed or not.",
                    "*/",
                    "",
                    "FDSG.registerOnReturnFromMinigame(\"Fill In The Quote\", () => {",
                    "    const wasCompleted = GameVars.runtimeScene.getGame().getVariables().get(\"MinigameFlags\").getChild(\"Fill In The Quote\").getAsBoolean();",
                    "    if (wasCompleted) {",
                    "        FDSG.bringInspectionIntoView(\"winQuoteMinigame\");",
                    "    } else {",
                    "        FDSG.bringInspectionIntoView(\"loseQuoteMinigame\");",
                    "    }",
                    "});"
                  ],
                  "parameterObjects": "",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": []
            },
            {
              "colorB": 228,
              "colorG": 176,
              "colorR": 74,
              "creationTime": 0,
              "folded": true,
              "name": "Debug Commands",
              "source": "",
              "type": "BuiltinCommonInstructions::Group",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "BooleanVariable"
                      },
                      "parameters": [
                        "DEBUG",
                        "True",
                        ""
                      ]
                    }
                  ],
                  "actions": [],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::JsCode",
                      "inlineCode": [
                        "const FDSG = gdjs.FDGameData;",
                        "const GameVars = FDSG.GameVars;",
                        "console.log(\"registering keys\");",
                        "FDSG.registerKeyPressFunction({",
                        "    key: \"f\",",
                        "    duration: \"justPressed\",",
                        "    keyPressFunction: () => {",
                        "        FDSG.debugPrint(\"log\", FDSG);",
                        "    }",
                        "});",
                        "",
                        "FDSG.registerKeyPressFunction({",
                        "    key: \"v\",",
                        "    duration: \"justPressed\",",
                        "    keyPressFunction: () => {",
                        "        FDSG.debugPrint(\"log\", GameVars);",
                        "    }",
                        "});",
                        "",
                        "FDSG.registerKeyPressFunction({",
                        "    key: \"r\",",
                        "    duration: \"justPressed\",",
                        "    keyPressFunction: () => {",
                        "        FDSG.debugPrint(\"log\", GameVars.runtimeScene);",
                        "    }",
                        "});",
                        "",
                        "FDSG.registerKeyPressFunction({",
                        "    key: \"i\",",
                        "    duration: \"justPressed\",",
                        "    keyPressFunction: () => {",
                        "        FDSG.debugPrint(\"log\", FDSG.Input);",
                        "    }",
                        "});"
                      ],
                      "parameterObjects": "",
                      "useStrict": true,
                      "eventsSheetExpanded": false
                    }
                  ]
                }
              ],
              "parameters": []
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetBooleanVariable"
                  },
                  "parameters": [
                    "DataInitialized",
                    "True",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "DebuggerTools::ConsoleLog"
                  },
                  "parameters": [
                    "\"Game Data Initialized\"",
                    "\"info\"",
                    "\"init\""
                  ]
                }
              ]
            }
          ]
        }
      ],
      "parameters": []
    },
    {
      "colorB": 228,
      "colorG": 176,
      "colorR": 74,
      "creationTime": 0,
      "folded": true,
      "name": "Main Game Loop",
      "source": "",
      "type": "BuiltinCommonInstructions::Group",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const FDSG = gdjs.FDGameData; // Simpler variables to use as reference",
            "const GameVars = FDSG.GameVars;",
            "const Game = runtimeScene.getGame();",
            "",
            "",
            "if (gdjs.evtTools.runtimeScene.sceneJustBegins(runtimeScene)) { // Runs only at the beginning of the scene",
            "    GameVars.runtimeScene = runtimeScene; // Update the current RuntimeScene object",
            "    FDSG.initScene();",
            "    FDSG.debugPrint(\"log\",\"Scene initialized\");",
            "    GameVars.isInspecting = false;",
            "    var fadeDuration = GameVars.Constants.TRANSITION_FADE_DURATION;",
            "    if (!Game.getVariables().get(\"FirstSceneInitialized\").getAsBoolean()) { // Fade into the game should be nice and long",
            "        fadeDuration = GameVars.Constants.FIRST_TRANSITION_FADE_DURATION;",
            "        Game.getVariables().get(\"FirstSceneInitialized\").setBoolean(true);",
            "    }",
            "    FDSG.initFade(fadeDuration, true);",
            "}",
            "",
            "var thisLayout = GameVars.currentLayout; // Store the layout to see if it changes with player input",
            "",
            "if (!GameVars._isFading && GameVars._currentLoadedMinigame != null) { // Check if we're returning from a minigame",
            "    const minigameName = GameVars._currentLoadedMinigame;",
            "    if (minigameName in FDSG.OnReturnFromMinigame) {",
            "        FDSG.OnReturnFromMinigame[minigameName](); // Run any registered function",
            "    }",
            "    GameVars._currentLoadedMinigame = null;",
            "}",
            "FDSG.handlePlayerInput(); // Handle all registered functions associated with clicking objects and pressing keys",
            "if (GameVars._isFading) {",
            "    var fadeEffect = runtimeScene.getInstancesOf(\"FadeScreen\")[0];",
            "    const fadeDuration = fadeEffect.getVariables().get(\"FadeDuration\").getAsNumber();",
            "    const fadeOpacity = fadeEffect.getVariables().get(\"Opacity\").getAsNumber();",
            "    if (fadeDuration < 0 && fadeOpacity >= 1) {",
            "        GameVars._isFading = false;",
            "        gdjs.evtTools.runtimeScene.replaceScene(runtimeScene, runtimeScene.getName());",
            "    } else if (fadeDuration > 0 && fadeOpacity <= 0) {",
            "        GameVars._isFading = false;",
            "        fadeEffect.deleteFromScene();",
            "    } else {",
            "        const deltaTime = fadeEffect.getElapsedTime(runtimeScene);",
            "        let newOpacity = fadeOpacity - (1/fadeDuration)*deltaTime;",
            "        fadeEffect.setEffectDoubleParameter(\"Opacity\", \"alpha\", newOpacity);",
            "        fadeEffect.getVariables().get(\"Opacity\").setNumber(newOpacity);",
            "    }",
            "}"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        },
        {
          "type": "BuiltinCommonInstructions::ForEach",
          "object": "InteractionButton",
          "conditions": [
            {
              "type": {
                "value": "PanelSpriteButton::PanelSpriteButton::LabelText"
              },
              "parameters": [
                "InteractionButton",
                "!=",
                "InteractionButton.labelText",
                ""
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "PanelSpriteButton::PanelSpriteButton::SetLabelTextOp"
              },
              "parameters": [
                "InteractionButton",
                "=",
                "InteractionButton.labelText",
                ""
              ]
            }
          ]
        }
      ],
      "parameters": []
    }
  ]
}